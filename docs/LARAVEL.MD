# LARAVEL

## Backend/WEB


### Что вы знаете о CORS?

CORS (Cross-Origin Resource Sharing, англ. «совместное использование ресурсов разных источников») — это стандарт, позволяющий предоставлять веб-страницам доступ к объектам сторонних интернет-ресурсов.
Сторонним считается любой интернет-ресурс, который отличается от запрашиваемого протоколом, доменом или портом.

Доступ предоставляется по специализированным запросам. Интернет-ресурс, принимающий запрос, содержит список доверенных источников, которым разрешен доступ к объектам. Страница-источник запроса получает доступ, если входит в список доверенных источников. Для предоставления доступа всем сторонним интернет-страницам используется маска «*».






### Перечислите преимущества HTTP/2 над HTTP 1.1;

HTTP 1.1 позволяет обрабатывать лишь один поступивший запрос на одно TCP-соединение, поэтому браузеру приходится устанавливать несколько соединений, чтобы обрабатывать одновременно несколько запросов.

Особенности HTTP/2

- Мультиплексированные потоки
- Отправка данных по инициативе сервера (Server Push)
- Используются улучшенные алгоритмы сжатия заголовков, что повышает производительность и безопасность.
- Улучшенные механизмы приоритезации потоков.
- Быстрое шифрование.


### Что такое репликация данных В БД?

### Расскажите о шардинге

#### Вертикальный шардинг
Вертикальный шардинг — это выделение таблицы или группы таблиц на отдельный сервер.

Например, в приложении есть такие таблицы:

- users — данные пользователей
- photos — фотографии пользователей
- albums — альбомы пользователей
Таблицу users Вы оставляете на одном сервере, а таблицы photos и albums переносите на другой. В таком случае в приложении Вам необходимо будет использовать соответствующее соединение для работы с каждой таблицей

#### Горизонтальный шардинг
Горизонтальный шардинг — это разделение одной таблицы на разные сервера. Это необходимо использовать для огромных таблиц, которые не умещаются на одном сервере. Разделение таблицы на куски делается по такому принципу:

- На нескольких серверах создается одна и та же таблица (только структура, без данных).
- В приложении выбирается условие, по которому будет определяться нужное соединение (например, четные на один сервер, а нечетные — на другой).
- Перед каждым обращением к таблице происходит выбор нужного соединения.


### Перечислите основные уязвимости которые могу появиться при разработки Web приложения;

### Какие основные типы ошибок в PHP и чем они отличаются?

Ошибки в PHP бывают:

- фатальные (fatal);
- не фатальные;
- пользовательские.

#### Fatal error в PHP 
одна из наиболее серьезных проблем. Такие дефекты появляются и при компиляции, и во время работы парсера либо PHP-скрипта. Основной нюанс заключается в том, что происходит прерывание исполнения скрипта.

- E_PARSE. Грубый недостаток в синтаксисе. PHP-интерпретатор не понимает, что вы вообще от него хотите.
- Интерпретатор PHP понимает, что хочет разработчик, но выполнить это не может по разным причинам. Выполнение скрипта будет прервано, однако произойдет именно в месте возникновения проблемы, то есть код сработает до того места, где находится ошибка. Примеры: не удалось обнаружить подключаемый файл PHP; было выброшено, но не было обработано исключение; разработчик пытался вызвать метод класса, причем данный метод не существует; отсутствует свободная память (превышен лимит директивы memory_limit).

#### Не фатальные
В данном случае выполнение скрипта не прерывается, однако именно эти дефекты часто находят тестировщики программного обеспечения.

- E_WARNING
- E_NOTICE: обращение к неопределенной переменной; обращение к элементу массива, когда элемент не существует; обращение к несуществующей константе; проблема, возникающая, если не конвертируются типы данных и т. п.
- E_DEPRECATED. Язык программирования PHP станет ругаться при использовании устаревших функций (т. е. функций, которые помечены в качестве deprecated);
- E_STRICT. Это тоже история про то, что нужно писать код правильно и обращать внимание на подсказки со стороны IDE, дабы потом не было мучительно больно и стыдно. К примеру, если вы вызовете нестатический метод как статику, код, отображенный ниже, функционировать будет, но ведь это как-то неправильно.

#### Пользовательские
E_USER_WARNING — некритическая ошибка;
E_USER_ERROR — критическая;
E_USER_NOTICE — речь идет о сообщениях, которые ошибками не являются.
Отдельно надо сказать про E_USER_DEPRECATED — напоминает о том, что  метод либо функция устарели, то есть пришло время переписать код.

````php
/**
 * @deprecated
 */
function fun() 
{
  //do smthing
}
````

### Что такое Contract'ы в экосистеме Laravel?

### Перечислите типы отношений в Eloquent;

### Расскажете о жизненном цикле запроса в Laravel;

### Какие, по вашему мнению, главные недостатки Eloquent ORM?

Согласно принципу, доменный объект должен иметь только одну зону ответственности, то есть только свою бизнес-логику. Вызывая его для сохранения данных, вы добавляете ему дополнительную зону ответственности, увеличивая сложность объекта, что усложняет его поддержку и тестирование.

### Что такое Facade? Какие плюсы и минусы вы можете отметить у этого шаблона?

### Напишите реализацию Singleton через контейнер зависимостей Laravel;

### Что такое «Нетерпеливая загрузка» в Eloquent?

В Eloquent отношения имеют функцию "ленивой загрузки". То есть они загружаются только при обращении к свойствам. Но помимо этого можно "нетерпеливо" загружать отношения во время загрузки родительской модели. Такая загрузка решает проблему N+1 запроса.  

````php
class Book extends Model {
   public function author() {
      return $this->belongsTo('App\Author');
   }
}
````

Для получения имён авторов используется такой цикл:

````php
$books = App\Book::all();

foreach ($books as $book) {
   echo $book->author->name;
}
````

Такой код выполнит 1 запрос, чтобы получить все книги из таблицы. А для получения имени автора будет сделан второй запрос внутри цикла. Таким образом этим кодом будет сделано N+1 запросов к базе (где N - это количество книг).

Чтобы уменьшить количество запросов, можно использовать "нетерпеливую" загрузку. Достаточно добавить метод "with", который добавит один запрос, но избавит от запроса в цикле

````php
$books = App\Book::with('author')->get();

foreach ($books as $book) {
   echo $book->author->name;
}
````



### Что такое Laravel?
Laravel – это PHP-фреймворк с открытым исходным кодом, созданный Тайлором Отвеллом в июне 2011 года. Он следует архитектурному шаблону MVC.

### Что такое контейнер IoC (инверсия контроля) или сервисный контейнер?

Инверсия контроля, или сокращенно IoC, является техникой, которая позволяет инвертировать контроль выполнения в сравнении с классическим процедурным кодом. Наиболее известная форма IoC – это конечно Инъекция зависимости или DI. Контейнер IoC в Laravel – одна из наиболее часто используемых его возможностей, хотя и возможно менее понимаемая.

Вот простой пример использования Инъекции зависимости, чтобы получить инверсию контроля.

````php
class JeepWrangler
{
public function __construct(Petrol $fuel)
{
$this->fuel = $fuel;
}

    public function refuel($litres)
    {
        return $litres * $this->fuel->getPrice();
    }
}

class Petrol
{
public function getPrice()
{
return 130.7;
}
}

$petrol = new Petrol;
$car = new JeepWrangler($petrol);

$cost = $car->refuel(60);
````


Используя инъекцию через конструктор, мы теперь делегировали создание инстанса Petrol вызывающему объекту, таким образом реализовав инверсию контроля. Наш класс JeepWrangler не должен знать, от куда он получит объект Petrol.

Но какое это все имеет отношение к Laravel? На самом деле очень большое. Laravel, если вы не знали, сам по себе является IoC контейнером. Контейнер это объект, который как вы уже могли догадаться, содержит другие объекты. Контейнер IoC в Laravel используется для хранения множества разных связей. Все что вы делаете в Laravel в какой-то степени взаимодействует с IoC контейнером. Это взаимодействие в большинстве случаев принимает форму получения связей.

Если вы откроете любой из существующих service provider’ов в Laravel, то скорее всего увидите в методе register что-то похоже на это (пример максимально упрощен).

````php
$this->app['router'] = $this->app->share(function($app) {return new Router;});
````


Вот очень, очень простая привязка. Она состоит из имени связи (router) и способа её получения (замыкания). Когда мы пытаемся получить эту связь из контейнера, мы в ответ получим инстанс Router.

Laravel обычно группирует схожие имена связей, например session и session.store.

Чтобы получить связь, мы можем использовать метод контейнера make.

````php
$router = $this->app->make('router');
````


Вот, что контейнер делает в своей самой базовой форме. Но, как и большинство вещей в Laravel, здесь внутри еще есть много всего, помимо привязок и разрешения классов.

### Что такое фасады Laravel?

Фасады предоставляют «статический» интерфейс к классам, доступным в сервис-контейнере. Laravel поставляется со множеством фасадов, предоставляющих доступ почти ко всем возможностям Laravel. Фасады Laravel служат «статическими прокси» для классов в сервис-контейнере, обеспечивая преимущества краткого выразительного синтаксиса, и поддерживая большую тестируемость и гибкость, чем традиционные статические методы.

Все фасады Laravel определены в пространстве имён Illuminate\Support\Facades. Поэтому мы можем легко обратиться к фасаду таким образом:

````php
use Illuminate\Support\Facades\Cache;

Route::get('/cache', function () {
return Cache::get('key');
});
````

Во многих примерах в документации по Laravel используются фасады для демонстрации различных возможностей фреймворка.

Фасады имеют много преимуществ. Они обеспечивают лаконичный, запоминающийся синтаксис, который позволяет вам использовать возможности Laravel, не запоминая длинные имена классов, которые должны внедряться или настраиваться вручную. Более того, благодаря уникальному использованию динамических методов PHP они легко тестируются.

### Что такое middleware Laravel?

Посредники (англ. middleware) предоставляют удобный механизм для фильтрации HTTP-запросов вашего приложения. Например, в Laravel есть посредник для проверки аутентификации пользователя. Если пользователь не аутентифицирован, посредник перенаправит его на экран входа в систему. Если же пользователь аутентифицирован, посредник позволит запросу пройти далее в приложение.

Конечно, посредники нужны не только для авторизации. CORS-посредник может пригодиться для добавления особых заголовков ко всем ответам в вашем приложении. А посредник логов может зарегистрировать все входящие запросы.

В Laravel есть несколько стандартных посредников, включая посредники для аутентификации и CSRF-защиты. Все они расположены в каталоге app/Http/Middleware.

### Что такое CSRF? Почему он используется?

Laravel позволяет легко защитить ваше приложение от атак с подделкой межсайтовых запросов (CSRF). Подделка межсайтовых запросов — тип атаки на сайты, при котором несанкционированные команды выполняются от имени аутентифицированного пользователя.

Laravel автоматически генерирует CSRF-“токен” для каждой активной пользовательской сессии в приложении. Этот токен используется для проверки того, что именно авторизованный пользователь делает запрос в приложение.

При определении каждой HTML-формы вы должны включать в неё скрытое поле CSRF-токена, чтобы посредник CSRF-защиты мог проверить запрос. Вы можете использовать вспомогательную функцию csrf_field() для генерирования поля токена:

````php
<form method="POST" action="/profile">
  {{ csrf_field() }}
  ...
</form>
````

Посредник VerifyCsrfToken, входящий в группу посредников web, автоматически проверяет совпадение токена в данных запроса с токеном, хранящимся в сессии.

### Что такое Bootstrap?

Bootstrap – это точка входа для запуска фреймворка Laravel.


### Что такое контракты laravel?

Контракты в Laravel — это набор интерфейсов, которые описывают основной функционал, предоставляемый фреймворком. Например, контракт Illuminate\Contracts\Queue\Queue определяет методы, необходимые для организации очередей, в то время как контракт Illuminate\Contracts\Mail\Mailer определяет методы, необходимые для отправки электронной почты.

Каждый контракт имеет свою реализацию во фреймворке. Например, Laravel предоставляет реализацию Queue с различными драйверами и реализацию Mailer, использующую SwiftMailer.

Все контракты Laravel живут в своих собственных репозиториях GitHub. Эта ссылка ведёт на все доступные контракты, а также на один отдельный пакет, который может быть использован разработчиками пакетов.

### Какие каталоги нуждаются в разрешении на запись для установки и запуска Laravel?
storage и bootsrap / cache

### Что такое Composer?
Composer – это пакетный менеджер зависимостей, предназначенный для упрощения загрузки и установки сторонних php библиотек в проект. Например, с помощью него можно очень просто добавить в разрабатываемый проект php пакеты, а также развернуть другие проекты, которые распространяются вместе с файлом «composer.json».

«composer.json» – это текстовый файл, в котором в формате JSON описаны все сторонние пакеты от которых зависит данный проект.

источник: https://maxyc.ru/programming/laravel/laravel-top-10-questions/


## Что такое Contract'ы в экосистеме Laravel?
«Контракты» Laravel – это набор интерфейсов, которые определяют основные службы фреймворка. Например, контракт Illuminate\Contracts\Queue\Queue определяет методы, необходимые для постановки заданий в очередь, а контракт Illuminate\Contracts\Mail\Mailer – для отправки электронной почты.

Каждый контракт имеет соответствующую реализацию, предусмотренную структурой. Например, Laravel предлагает реализацию очереди с множеством драйверов и реализацию почтовой программы, которая работает на SwiftMailer.

Все контракты Laravel находятся в их собственном репозитории GitHub. Это обеспечивает быстрый доступ к списку всех доступных контрактов, а также единый, отдельный пакет, который используется разработчиками пакетов, взаимодействующих со службами Laravel.

Фасады и глобальные помощники Laravel обеспечивают простой способ использования служб Laravel без объявления типов зависимости и извлечения их реализаций из контейнера служб. В большинстве случаев каждый фасад имеет эквивалентный контракт.

В отличие от фасадов, которые не требуют, чтобы они находились в конструкторе вашего класса, контракты позволяют вам определять явные зависимости для ваших классов. Некоторые разработчики предпочитают явно определять свои зависимости таким образом и поэтому предпочитают использовать контракты, в то время как другие разработчики пользуются удобством фасадов. В общем, большинство приложений могут без проблем использовать фасады во время разработки.

## Что такое Глобальные помощники в экосистеме Laravel?

В дополнении к фасадам, Laravel предлагает множество глобальных «вспомогательных функций», которые упрощают взаимодействие с общими функциями Laravel. Вот некоторые из глобальных помощников, с которыми вы можете взаимодействовать – это view, response, url, config и т.д. Каждый помощник, предлагаемый Laravel, задокументирован с соответствующей функцией;

Например, вместо использования фасада Illuminate\Support\Facades\Response для генерации ответа JSON, мы можем просто использовать функцию response. Поскольку помощники доступны глобально, то вам не нужно импортировать какие-либо классы, чтобы использовать их:

````php
use Illuminate\Support\Facades\Response;

Route::get('/users', function () {
   return Response::json([
      // ...
   ]);
});

Route::get('/users', function () {
   return response()->json([
      // ...
   ]);
});
````

## Жизненный цикл запроса

### index.php
Точкой входа для всех запросов к приложению Laravel является файл public/index.php. Все запросы направляются в этот файл конфигурацией вашего веб-сервера (Apache / Nginx). Файл index.php не содержит большого количества кода. Скорее, это отправная точка для загрузки остальной части фреймворка.

Файл index.php загружает автозагрузчик, созданный менеджером пакетов Composer, а затем извлекает экземпляр приложения Laravel из bootstrap/app.php. Первым действием, предпринимаемым самим Laravel, является создание экземпляра приложения / контейнера служб.

### HTTP-ядро и ядро консоли
Затем входящий запрос отправляется либо HTTP-ядру, либо ядру консоли, в зависимости от типа запроса, поступающего в приложение. Эти два ядра служат центральным местом, через которое проходят все запросы. А пока давайте сосредоточимся на ядре HTTP, которое находится в app/Http/Kernel.php.

HTTP-ядро расширяет класс Illuminate\Foundation\Http\Kernel, который определяет массив загрузчиков (bootstrappers), запускающихся до выполнения запроса. Эти загрузчики настраивают обработку ошибок, логирование, определяют среду приложения и выполняют другие задачи, которые необходимо выполнить до фактической обработки запроса.

Ядро HTTP также определяет список HTTP-посредников, через которые должны пройти все запросы, прежде чем они будут обработаны приложением. Эти посредники обрабатывают чтение и запись HTTP-сессий, определяют, находится ли приложение в режиме обслуживания, проверяют токен CSRF и многое другое.

Сигнатура метода handle HTTP-ядра довольно проста: он получает запрос (Request) и возвращает ответ (Response). Думайте о ядре как о большом черном ящике, который представляет все ваше приложение. Дайте ему HTTP-запросы, и он вернет HTTP-ответы.

Одним из наиболее важных действий начальной загрузки ядра является загрузка поставщиков служб вашего приложения. Все поставщики служб приложения настраиваются в массиве providers конфигурационного файла config/app.php.

Laravel будет перебирать этот список поставщиков и создавать экземпляры каждого из них. После создания экземпляров поставщиков, будет вызван метод register всех поставщиков. Затем, как только все поставщики будут зарегистрированы, будет вызван метод boot каждого из них. Это сделано для того, чтобы те поставщики служб, которые имеют зависимости от других поставщиков, могли быть вызваны гарантированно после создания своих зависимостей, вызываемых в методе boot.

Поставщики служб несут ответственность за загрузку всевозможных компонентов инфраструктуры, таких как компоненты БД, очереди, валидации и маршрутизации. По сути, каждая основная функция Laravel загружается и настраивается поставщиком служб. Поскольку они запускают и настраивают так много функций, предлагаемых фреймворком, поставщики служб являются наиболее важным аспектом всего процесса начальной загрузки Laravel.

### Маршрутизация
Одним из наиболее важных поставщиков служб в вашем приложении является App\Providers\RouteServiceProvider. Этот поставщик загружает файлы маршрутов, содержащиеся в каталоге routes приложения.

После того как приложение было загружено и все поставщики служб зарегистрированы, Request будет передан маршрутизатору для исполнения. Маршрутизатор отправит запрос на маршрут или контроллер, а также запустит посредник для конкретного маршрута.

Посредники обеспечивают удобный механизм фильтрации или интерпретации HTTP-запросов, поступающих в ваше приложение. Например, Laravel содержит посредника, который проверяет аутентификацию пользователя вашего приложения. Если пользователь не аутентифицирован, посредник перенаправит пользователя, например, на экран входа в систему. Однако, если пользователь аутентифицирован, посредник позволит запросу продолжить работу в приложении. Некоторые посредники назначаются всем маршрутам в приложении, например, определенным в свойстве $middleware вашего ядра HTTP, тогда как некоторые назначаются только для определенных маршрутов или групп маршрутов.

Если запрос проходит через всех посредников, назначенных определенному маршруту, то метод маршрута или контроллера будет выполнен, а ответ, возвращенный методом маршрута или контроллера, будет отправлен обратно через цепочку посредников маршрута.

### Окончание
Когда метод маршрута или контроллера вернет ответ, тогда ответ отправится обратно через посредников маршрута, обеспечивая приложению возможность изменения или проверки исходящего ответа.

Наконец, как только ответ проходит через посредников, метод handle ядра HTTP возвращает объект ответа, а файл index.php вызывает метод send для возвращенного ответа. Метод send отправляет содержимое ответа в веб-браузер пользователя. Мы завершили наш путь через весь жизненный цикл запроса Laravel!


