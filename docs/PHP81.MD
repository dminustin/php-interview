## Новое в PHP8.1

### Перечисления
Введение Enum избавляет от необходимости использовать костыльные решения (например, создавать перечисления из классов) и подтягивать сторонние пакеты. Обновление действительно ждали — об этом свидетельствует популярность руководств по реализации перечислений в PHP и библиотек Enum и PHP-enum.

Перечисление в виде типа дает контроль над кодом, помогает соблюдать принцип DRY и снизить сложность восприятия кода.

Предположим, что приложение должно учитывать времена года. Хорошо, если они реализованы в виде строк (например, $season = 'winter'), но если речь идет о числах в виде $season = 0, код очень скоро начинает вызывать вопросы. Строки и числа, используемые для перечислений, тяжело валидировать. Для каждой функции, в которую приходит строка или число $enumVar, нужно проверять, что все работает хорошо. С Enum валидация становится проще:

````php
enum Status
{
case Draft;
case Published;
case Archived;
}
function acceptStatus(Status $status) {...}
````

### Readonly-свойства
Фича полезна при реализации объектов типа value и data transfer. Она предназначена для работы с вычисляемыми значениями и позволяет не беспокоиться, что значение будет перезаписано.

При организации классов бывают случаи, когда нужна «вычисляемая константа». В предыдущих версиях разработчик создавал функцию, которая вызывается каждый раз, когда нужно получить значение константы, и забивает стек вызовов. Альтернативное решение — использование статистических переменных, которые повышают вероятность ошибки из-за своей изменчивости. Readonly поможет однозначно понять, что переменную присвоили, и работать с ее значением.

````php
class BlogData
{
    public readonly Status $status;

    public function __construct(Status $status)
    {
        $this->status = $status;
    }
}
````

### Файберы

Примитивы, которые позволяют синхронно держать в памяти несколько процессов и запускать каждый из них при необходимости. Вероятно, главная задача нововведения — сделать «асинхронные» участки кода быстрее и упростить их поддержку.

````php
$response = $httpClient->request('https://example.com/');
print json_decode($response->getBody()->buffer())['code'];
````

Файбер вряд ли будет широко использоваться при разработке ПО на высоких уровнях. Но на более низких (фреймворки Laravel, Symfony, Yii2, etc; пакеты для асинхронной работы ReactPHP и Amp) они точно будут полезны. В частности, для повышения производительности, переписывания части блоков кода с yield и, возможно, для переписывания реализаций корутин на основе генератора.

### Новые функции
- Array_is_list — функция помогает проверить, что ключи элементов массива это числа идущие по порядку от 0.
- fsync и fdatasync — функции дополнительной проверки при редактировании файла, которые синхронизируют изменения. Интересно, что на Windows разницы между функциями нет: fdatasync в данном случае — ссылка на fsync.
- Serializable становится deprecated — после перехода на новую версию придется удалить из кода implements Serializable и поменять все функции serialize()/unserialize() на __serialize()/__unserialize()
- resource становится deprecated — если resource использовался в коде, при переходе на новую версию придется менять все вхождения.

### Другие обновления
Оставшиеся обновления можно поделить на два типа:
Делают код чище. К этой категории относятся явное восьмеричное числовое обозначение, тип возвращаемого значения never, callback-функции как объекты первого типа, расширенная инициализация объектов и пересечение типов.
Дают больше контроля в коде. Здесь речь идет о финальных константах класса.

Отдельно стоит отметить прирост производительности в новой версии: на 23% для демо-приложения на фреймворке Symfony и на 3,5% для WordPress по сравнению с PHP 8. Важно понимать, что производительность часто индивидуальна и зависит от конкретного приложения.

