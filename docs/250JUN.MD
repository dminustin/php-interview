# 250 Вопросов Джуну / Мидлу / Сеньору
Сурс: https://techrocks.ru/2021/04/18/250-php-job-interview-questions/

Сайт DOU.UA опубликовал статью со списком вопросов, которые задают PHP-разработчикам на технических собеседованиях. Разумеется, список не является исчерпывающим, но его формировали специалисты, выступающие в роли интервьюеров на собеседованиях.

Выкинул практические задания как ненужные, добавил ответы

# Junior

### Что такое ссылки?

Ссылки в PHP - это средство доступа к содержимому одной переменной под разными именами.


### Каковы основные операции с использованием ссылок?

Есть три основных операции с использованием ссылок: присвоение по ссылке, передача по ссылке и возврат по ссылке.
ссылки PHP позволяют создать две переменные указывающие на одно и то же значение.

При присвоении, передаче или возврате неинициализированной переменной по ссылке, происходит её создание.

При присвоении, ссылки PHP позволяют создать переменные, указывающие на одно и то же значение.

````php
$a = &$b;
$a и $b здесь абсолютно эквивалентны, но это не означает, что $a указывает на $b или наоборот. Это означает, что $a и $b указывают на одно и то же значение.
````
Вы можете передать переменную в функцию по ссылке, чтобы она могла изменять значение аргумента. Синтаксис выглядит следующим образом:

Возврат по ссылке используется в тех случаях, когда вы хотите использовать функцию для выбора переменной, с которой должна быть связана данная ссылка. Не используйте возврат по ссылке для увеличения производительности. Ядро PHP само занимается оптимизацией.

При сбросе ссылки, просто разрывается связь имени и содержимого переменной. Это не означает, что содержимое переменной будет уничтожено. Например:

unset($a); 

### Назовите простые типы данных, поддерживаемые в РНР.
````php
bool (логический тип)
int (целые числа)
float (дробные числа)
string (строки)
array (массивы)
object (объекты)
callable (функции)
mixed (любой тип)
resource (ресурсы)
null (отсутствие значения)
````
Из этих типов данных первые четыре являются скалярными: bool, int, float, string

### Что такое инкремент и декремент, в чем разница между префиксным и постфиксным инкрементом и декрементом?

Унарные операции увеличивают и уменьшают на единицу число, записанное в переменную.

При использовании префиксной нотации сначала происходит изменение переменной, а потом возврат. При использовании постфиксной нотации — наоборот: сначала возврат, а потом изменение переменной

### Что такое рекурсия?
В общем смысле рекурсия это отображение чего-либо внутри самого себя. Рекурсивные алгоритмы используют рекурсивные функции, обладающие данным свойством.

Существует два варианта реализации рекурсивных функций: простой и сложный. В простом случае рекурсивная функция вызывает саму себя. В сложном — функция вызывает другую функцию, которая вызывает исходную функцию, с которой всё начиналось.


### В чем разница между =, == и ===?

Присваивание, сравнение, строгое сравнение (сравниваются так же типы)

Существенная разница в том, что оператор сравнения двойное равенство сравнивает значения двух операндов. Напротив, оператор сравнения тройного равенства сравнивает значение и тип операндов.

### Какие знаете принципы ООП?

- инкапсуляция
  Инкапсуляция — объединение полей и методов в классе, с целью закрыть прямой доступ к полям и открыть его для методов, которые этими полями управляют.

Согласно инкапсуляции, доступ к полям рекомендуется закрывать используя соответствующие спецификаторы доступа. Чтобы предоставить возможность вносить изменения или получать значения полей,  создаются специальные  методы.


- наследование

позволяет создавать классы на основе уже существующих. Тем самым облегчая задачу по созданию новых классов с точки зрения использования уже существующего программного кода. Класс, от которого произошло наследование, называется базовым или родительским. Классы, которые произошли от базового, называются потомками, наследниками или производными классами. В PHP также используются абстрактные классы.


- абстракция
  это класс, содержащий хотя бы один абстрактный метод. Он описан в программе, имеет поля, методы и не может использоваться для непосредственного создания объекта. То есть от абстрактного класса можно только наследовать. Объекты создаются только на основе производных классов, наследованных от абстрактного.

- полиморфизм
  в программировании означает возможность использования одного имени для методов  разных классов находящихся в одной иерархии наследования (т.е. в родственных классах) с целью выполнения схожих действий.

Создание в производном классе метода с таким же именем что и имя метода родительского класса, называется переопределением метода.

Суть переопределения метода — производный класс в переопределяемом методе делает похожее, но отличающееся действие, чем действие метода родительского класса.

### Какая система типов используется в PHP? Опишите плюсы и минусы.
Используется динамическая типизация, но можно включить строгую типизацию
declare(strict_types=1)

Плюсы: можно писать плохой код, который будет работать

Минусы: можно писать плохой код, который будет работать

### Чем отличаются ключевые слова: include и require

функция include() выдает предупреждение, но скрипт продолжит выполнение, а функция require() выдает предупреждение и фатальную ошибку, т. е. скрипт не будет продолжать выполнение

### Что такое интерфейсы? Используете ли вы их? Если да — расскажите об этом.

Интерфейс определяет абстрактный дизайн, которому должен соответствовать применяющий его класс. Интерфейс определяет методы без реализации. А класс затем применяет интерфейс и реализует эти методы. Применение интерфейса гарантирует, что класс имеет определенный функционал, описываемый интерфейсом.

Интерфейс определяется с помощью ключевого слова interface, за которым следует имя интерфейса и блок кода интерфейса в фигурных скобках:

### Что такое абстрактный класс и чем он отличается от интерфейса?

Абстрактный класс используется для определения базового каркаса или проекта дочерних классов. Класс, который расширяет абстрактный класс, должен определять некоторые или все его абстрактные методы.

Экземпляры абстрактных классов не могут быть созданы напрямую.

Интерфейс / Абстрактный класс
Поддерживаем множественное наследование // Не поддерживаем множественное наследование
Абстрактный класс // Может содержать data members
Не содержит конструктор // Может содержать конструктор
Содержит только объявление методов (сигнатуры методов) // Может содержать как сигнатуры методов так и их реализации
Не может иметь модификаторов доступа - все методы по умолчанию публичные // Может иметь модификаторы доступа
Методы не могут быть статическими // Только методы, содержащие реализацию, могут быть объявлены статическими

### Может ли абстрактный класс содержать частный метод?

Нет, если частный (private) метод объявлен абстрактным.

### Какие модификаторы видимости есть в РНР?
public: к свойствам и методам, объявленным с данным модификатором, можно обращаться из внешнего кода и из любой части программы
protected: свойства и методы с данным модификатором доступны из текущего класса, а также из классов-наследников
private: свойства и методы с данным модификатором доступны только из текущего класса

### Какие магические методы вы знаете и как их применяют?
Магические методы - это специальные методы, которые переопределяют действие PHP по умолчанию, когда над объектом выполняются определённые действия.

Следующие названия методов считаются магическими: __construct(), __destruct(), __call(), __callStatic(), __get(), __set(), __isset(), __unset(), __sleep(), __wakeup(), __serialize(), __unserialize(), __toString(), __invoke(), __set_state(), __clone() и __debugInfo()

Метод __set() будет выполнен при записи данных в недоступные (защищённые или приватные) или несуществующие свойства.

Метод __get() будет выполнен при чтении данных из недоступных (защищённых или приватных) или несуществующих свойств.

Метод __isset() будет выполнен при использовании isset() или empty() на недоступных (защищённых или приватных) или несуществующих свойствах.

Метод __unset() будет выполнен при вызове unset() на недоступном (защищённом или приватном) или несуществующем свойстве.

### Что такое генераторы и как их использовать?
Генераторы предоставляют лёгкий способ реализации простых итераторов без использования дополнительных ресурсов или сложностей, связанных с реализацией класса, реализующего интерфейс Iterator.

Генератор позволяет вам писать код, использующий foreach для перебора набора данных без необходимости создания массива в памяти, что может привести к превышению лимита памяти, либо потребует довольно много времени для его создания. Вместо этого, вы можете написать функцию-генератор, которая, по сути, является обычной функцией, за исключением того, что вместо возврата единственного значения, генератор может возвращать (yield) столько раз, сколько необходимо для генерации значений, позволяющих перебрать исходный набор данных.

````php
function xrange($start, $limit, $step = 1) {
    for ($i = $start; $i >= $limit; $i += $step) {
        yield $i;
    }
}
````
вызов range(0, 1000000) приведёт к использованию более 100 МБ
Обратите внимание, что и range() и xrange() дадут один и тот же вывод
````php
echo 'Нечётные однозначные числа с помощью range():  ';
foreach (range(1, 9, 2) as $number) {
    echo "$number ";
}
echo "\n";

echo 'Нечётные однозначные числа с помощью xrange(): ';
foreach (xrange(1, 9, 2) as $number) {
    echo "$number ";
}
````

### Что делает оператор yield?
В самом простом варианте оператор "yield" можно рассматривать как оператор "return", за исключением того, что вместо прекращения работы функции, "yield" только приостанавливает её выполнение и возвращает текущее значение, и при следующем вызове функции она возобновит выполнения с места, на котором прервалась.

### Что такое traits? Альтернативное решение? Приведите пример.
Трейты — альтернативный механизм переиспользования общего кода в разных классах. Он устраняет ограничения, которыми обладает наследование и заменяет его.

Трейты похожи на абстрактные классы. Они реализуют какую-то общую функциональность и с ними нельзя работать напрямую. Единственный способ использовать их – включение в другие классы.

Трейты в отличие от наследования, не фиксируют структуру классов. Любой класс может включать в себя любое количество трейтов.

````php
trait Magic
{
    // Доступно только внутри трейта
    private $properties;

    public function __get($key) {return $this->properties[$key] ?? null;}

    public function __set($key, $value) {$this->properties[$key] = $value;}
}
````

````php
class Config
{
    // Включение трейта в класс
    use Magic;
}

$config = new Config();
$config->key = 'value';
echo $config->key;
````

### Опишите поведение при использовании traits с одинаковыми именами полей и / или методов.

В случае если в классе будет объявлен метод, с таким же именем как в трейтах, то будет использоваться именно он и никаких ошибок не будет
В случае, если в классе НЕТ такого метода, а в трейтах есть методы с одинаковыми именами, будет Fatal Error. Устранить его можно указав какой метод надо использовать с помощью ключевого слова insteadof.

````php
class Talker {
    use A, B {
        B::smallTalk insteadof A;
        A::bigTalk insteadof B;
    }
}
````

### Будут ли доступны частные методы trait в классе?
в использующем трейт классе будут доступны как публичные, так и приватные методы и свойства класса.

### Можно ли компоновать traits в trait?
Трейты, подобно классам, также могут использовать другие трейты.

### Расскажите об обработке ошибок и исключения (try catch, finaly и throw).
Модель исключений (exceptions) в PHP похожа с используемыми в других языках программирования. Исключение можно сгенерировать (выбросить) при помощи оператора throw, и можно перехватить (поймать) оператором catch. Код генерирующий исключение, должен быть окружён блоком try, для того, чтобы можно было перехватить исключение. Каждый блок try должен иметь как минимум один соответствующий ему блок catch или finally.

В случае, если выброшено исключение, для которого нет блока catch в текущей функции, это исключение будет "всплывать" по стеку вызова, пока не будет найден подходящий блок catch. При этом, все встреченные блоки finally будут исполнены. Если стек вызовов раскрутится до глобальной области видимости, не встретив подходящего блока catch, программа завершит работу с фатальной ошибкой, если только у вас не настроен глобальный обработчик исключений.

### Что такое type hinting, как работает, зачем нужен?
Type Hinting — это механизм, который позволяет явно указывать типы параметров. Интерпретатор использует их и применяет исключение в тех ситуациях, когда тип не соответствует ожидаемому.

### Что такое namespace-ы и зачем они нужны?
Пространства имен позволяют избежать конфликта имен и сгруппировать функционал. Внутри пространства имен могут быть размещены классы, интерфейсы, функции и константы.

Если какая-та конструкция (например, класс или функция) определена вне любого пространства имен, то считается, что она расположена в глобальном пространстве имен.

Определение пространства имен
Для создания пространства имен применяется директива namespace, после которой идет название пространства имен

### Сравнение значений переменных в РНР и подводные камни? Приведение типов. Что изменилось в PHP 8 в этом контексте?
В PHP8, сравнивает строку и число как числа только если строка представляет собой число. Иначе, число будет конвертировано в строку, и будет производится строковое сравнение.

### Как работает session в РНР, где хранится, как инициализируется?
Сессия — это механизм для сохранения информации на разных веб-страницах для идентификации пользователей при навигации по сайту или приложению.
Использовать функцию session_start
Это метод, который вы встретите чаще всего, когда сессия запускается функцией session_start.

Если вам необходимо использовать сессии во всем приложении, вы также можете автоматически начинать их без использования функции session_start.

В файле php.ini есть опция конфигурации, которая позволяет автоматически запускать сессии для каждого запроса — session.auto_start. По умолчанию для нее установлено 0, но вы можете установить значение 1, чтобы включить функцию автоматического запуска.

Данные сессий хранятся на сервере. По умолчанию они записываются в файлы, но можно задать свой собственный механизм хранения данных сессий (например с использованием базы данных). Если хотите подробностей, смотрите функцию session_set_save_handler.

### Суперглобальные массивы. Какие знаете? Как использовали?
Массивы, доступные отовсюды из приложения, например, $_SERVER, $_GET, $_POST и другие

### Сравните include vs required, include_once vs required_once.
функция include() выдает предупреждение, но скрипт продолжит выполнение, а функция require() выдает предупреждение и фатальную ошибку, т. е. скрипт не будет продолжать выполнение
once говорит о том, что загрузить один и тот же файл нужно всего один раз.

### Что означает сложность алгоритма?
Понятие «сложность алгоритма» (обозначается как Big O). Оно даёт понимание того, насколько эффективен алгоритм.
В информатике алгоритмы сравниваются друг с другом по их алгоритмической сложности. Эта сложность оценивается как количество выполняемых операций алгоритмом для достижения своей цели. Например разные способы сортировки требуют очень разного количества "проходов" по массиву перед тем как массив будет полностью отсортирован.

### Что такое замыкание в PHP? Приведите пример.
Анонимные функции, также известные как замыкания (closures), позволяют создавать функции, не имеющие определённых имён. Они наиболее полезны в качестве значений callable-параметров, но также могут иметь и множество других применений.

Анонимные функции реализуются с использованием класса Closure.

### В чем разница между замыканием в PHP и JavaScript?
В JavaScript замыкание можно рассматривать как область видимости: когда вы определяете функцию, она молча наследует область, в которой она определена, которая называется замыканием, и сохраняет ее независимо от того, где она используется. Несколько функций могут совместно использовать одно и то же замыкание, и они могут иметь доступ к нескольким замыканиям, если они находятся в доступной области.

В PHP замыкание — это вызываемый класс, к которому вы вручную привязываете свои параметры.

### Что такое позднее связывание? Расскажите о поведении и применения static.
PHP реализует функцию, называемую позднее статическое связывание, которая может быть использована для того, чтобы получить ссылку на вызываемый класс в контексте статического наследования.

Слово «self», в строке return self::$model; указывает на текущий класс
Если слово «self» заменить на «static», то мы получим «позднее статическое связывание», т.е. связь будет установлена с тем классом, который вызывает данный код

### Как переопределить хранение сессий?
Например, в настройках session.save_handler

### Расскажите о SPL-библиотеке (Reflection, autoload, структуры данных).

spl_autoload_register — Регистрирует заданную функцию в качестве реализации метода __autoload()
Автолоадер используется для поиска и включения нужного файла, содержащего требуемый класс

### Расскажите о принципах SOLID.

#### Принцип единственной ответственности (Single responsibility)
Принцип единственной ответственности гласит — «На каждый объект должна быть возложена одна единственная обязанность». Т.е. другими словами — конкретный класс должен решать конкретную задачу — ни больше, ни меньше.

#### Принцип открытости/закрытости (Open-closed)
Данный принцип гласит — "программные сущности должны быть открыты для расширения, но закрыты для модификации". На более простых словах это можно описать так — все классы, функции и т.д. должны проектироваться так, чтобы для изменения их поведения, нам не нужно было изменять их исходный код.

#### Принцип подстановки Барбары Лисков (Liskov substitution)
«Объекты в программе могут быть заменены их наследниками без изменения свойств программы».

При использовании наследника класса результат выполнения кода должен быть предсказуем и не изменять свойств метод

#### Принцип разделения интерфейса (Interface segregation)
Данный принцип гласит, что «Много специализированных интерфейсов лучше, чем один универсальный»

Соблюдение этого принципа необходимо для того, чтобы классы-клиенты использующий/реализующий интерфейс знали только о тех методах, которые они используют, что ведёт к уменьшению количества неиспользуемого кода.

#### Принцип инверсии зависимостей (Dependency Invertion)
«Зависимости внутри системы строятся на основе абстракций. Модули верхнего уровня не зависят от модулей нижнего уровня. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций». Данное определение можно сократить — «зависимости должны строится относительно абстракций, а не деталей».

### Расскажите о шаблонах GRASP.
GRASP — General Responsibility Assignment Software Patterns (основные шаблоны распределения обязанностей в программном обеспечении)

GRASP состоит из 9 шаблонов:
- Creator
- Controller
- Pure Fabrication
- Information Expert
- High Cohesion
- Indirection
- Low Coupling
- Polymorphism
- Protected Variations

#### Информационный эксперт (Information Expert)
Ответственность должна быть назначена тому, кто владеет максимумом необходимой информации для исполнения — информационному эксперту.

В следующем примере на C# класс Customer содержит ссылки на все заказы клиентов, следовательно логично разместить тут метод для подсчета общей стоимости заказов

#### Создатель (Creator)
Creator или Создатель — суть ответственности такого объекта в том, что он создает другие объекты. Сразу напрашивается аналогия с абстрактной фабрикой.

По сути шаблон проектирования Абстрактная фабрика (создание объектов концентрируется в отдельном классе) это альтернатива создателя.

Но есть ряд моментов, которые должны выполняться, когда мы наделяем объект ответственностью создателя:

- Создатель содержит или агрегирует создаваемые объекты
- Создатель использует создаваемые объекты
- Создатель знает, как проинициализировать создаваемый объект
- Создатель записывает создаваемые объекты
- Создатель имеет данные инициализации

#### Controller
Шаблон сontroller призван решить проблему разделения интерфейса и логики в интерактивном приложении. Это не что иное, как хорошо известный контроллер из MVC парадигмы. Контролер отвечает за обработку запросов и решает кому должен делегировать запросы на выполнение. Если обобщить назначение сontroller, то он должен отвечать за обработку входных системных сообщений.

#### Слабая связанность (зацепление) или Low Coupling
Если объекты в приложении сильно связанны, то любой их изменение приводит к изменениям во всех связанных объектах. А это неудобно и порождает множество проблем. Low coupling как раз говорит о том что необходимо, чтобы код был слабо связан и зависел только от абстракций. Слабая связанность так же встречается в SOLID принципах как The Dependency Inversion Principle​ (DIP) и слабая связанность по сути это реализация Dependency Injection принципа. Когда мы уходим от конкретных реализаций и абстрагируемся на уровнях интерфейсов(которые легко подменять нужными нам реализациями), тогда код не завязан на определенные реализации.

#### Высокая связанность (High Cohesion)
По сути High Cohesion очень тесно связанна с Single Responsibility Principle​ (SRP) с SOLID принципов. High Cohesion получается в результате соблюдения SRP.

High Cohesion принцип говорит о том, что класс должен стараться выполнять как можно меньше не специфичных для него задач, и иметь вполне определенную область применения. Только с опытом приходит понимание балансировки между High Cohesion и Low Coupling. считается что Low Coupling и High Cohesion) это инь и янь проектирования ПО. Некорректное юзание High Cohesion порождает неправильное Low Coupling и наоборот.

#### Чистая выдумка (Pure Fabrication)
Pure Fabrication или чистая выдумка, или чистое синтезирование. Здесь суть в выдуманном объекте. Аналогом может быть шаблон Service (сервис) в парадигме DDD.

Какую проблему решает Pure Fabrication?

- Уменьшает зацепление ( Low Coupling);
- Повышает связанность (High Cohesion) ;
- Упрощает повторное использование кода.

К примеру у вас есть объект Customer и следую шаблону  информационный эксперт вы наделили его логикой которую мы показывали выше, как вы реализуете сохранение Customera в БД?

Так вот следуя Pure Fabrication принципу, мы создадим Сервис или репозиторий который будет доставать и сохранять такой объект в базу данных.

#### Посредник (Indirection)

Indirection или посредник. Можно столкнуться с таким вопросом: «Как определить ответственность объекта и избежать сильной связанности между объектами, даже если один класс нуждается в функционале (сервисах), который предоставляет другой класс?»

Решение: возложите ответственность на промежуточный объект, чтобы он осуществлял связь между другими компонентами или службами, чтобы они не были напрямую связаны. Такое решение можно сделать с помощью GoF паттерна медиатор

#### Полиморфизм (Polymorphism)

Полиморфизм позволяет реализовывать одноименные публичные методы, позволяя различным классам выполнять различные действия при одном и том же вызове. То есть объекты классов Square и Circle могут отображаться(реализовывать метод render) по разному несмотря не то, что они оба подклассы Shape, метод render определен в Shape. (Overriding).

Принцип полиморфизма является основополагающим в ООП. В этом контексте принцип тесно связан с GoF паттерном strategy. Это самый яркий пример реализации полиморфизма.

#### Устойчивость к изменениям (Protected Variations)

Проблема: Как спроектировать объекты, подсистемы и системы таким образом, чтобы изменения или нестабильность этих элементов не оказывали нежелательного влияния на другие элементы?

Решение: Определите точки прогнозируемого изменения или нестабильности, распределите обязанности по созданию стабильного интерфейса вокруг них.

По мнению многих это самый важный принцип который косвенно связан с остальными принципами GRASP. В настоящее время одним из наиболее важных показателей качества кода является простота изменений. Как архитекторы и программисты, мы должны быть готовы к постоянно меняющимся требованиям. Это не является «nice to have» атрибутом - это «must-have» в любом приложении и наша обязанность как программистов и архитекторов нашей системы это обеспечить.

### Расскажите о Dependency Injection: что такое DI-контейнеры? Какие есть варианты реализаций?

Внедрение зависимости — процесс предоставления внешней зависимости программному компоненту. Является специфичной формой «инверсии управления» (Inversion of control, IoC), когда она применяется к управлению зависимостями. В полном соответствии с принципом единственной обязанности объект отдаёт заботу о построении требуемых ему зависимостей внешнему, специально предназначенному для этого общему механизму.

Приложение может предоставить эти зависимости при создании класса или передать их функциям, которым нужна каждая зависимость.

Требуемую зависимость можно передать как:
- аргумент в конструкторе
- установить через setter

### Что вам известно о MVC?
Концепция MVC (Model-View-Controller: модель-вид-контроллер)

Контроллер управляет запросами пользователя (получаемые в виде запросов HTTP GET или POST, когда пользователь нажимает на элементы интерфейса для выполнения различных действий). Его основная функция — вызывать и координировать действие необходимых ресурсов и объектов, нужных для выполнения действий, задаваемых пользователем. Обычно контроллер вызывает соответствующую модель для задачи и выбирает подходящий вид.

Модель - это данные и правила, которые используются для работы с данными, которые представляют концепцию управления приложением. В любом приложении вся структура моделируется как данные, которые обрабатываются определённым образом. Что такое пользователь для приложения — сообщение или книга? Только данные, которые должны быть обработаны в соответствии с правилами (дата не может указывать в будущее, e-mail должен быть в определённом формате, имя не может быть длиннее Х символов, и так далее).

Вид обеспечивает различные способы представления данных, которые получены из модели. Он может быть шаблоном, который заполняется данными. Может быть несколько различных видов, и контроллер выбирает, какой подходит наилучшим образом для текущей ситуации.

Веб приложение обычно состоит из набора контроллеров, моделей и видов. Контроллер может быть устроен как основной, который получает все запросы и вызывает другие контроллеры для выполнения действий в зависимости от ситуации.

### Что вам известно о шаблонах GoF?
Шаблоны проектирования "банды четырёх (GoF)"

Паттернами проектирования (Design Patterns) называют решения часто встречающихся проблем в области разработки программного обеспечения. В данном случае предполагается, что есть некоторый набор общих формализованных проблем, которые довольно часто встречаются, и паттерны предоставляют ряд принципов для решения этих проблем.

Концепцию паттернов впервые описал Кристофер Александер в книге «Язык шаблонов. Города. Здания. Строительство».

Идея показалась привлекательной авторам Эриху Гамму, Ричарду Хелму, Ральфу Джонсону и Джону Влиссидесу, их принято называть «бандой четырёх» (Gang of Four). В 1995 году они написали книгу «Design Patterns: Elements of Reusable Object-Oriented Software», в которой применили концепцию типовых паттернов в программировании. В книгу вошли 23 паттерна, решающие различные проблемы объектно-ориентированного дизайна.

#### Порождающие паттерны:
Порождающие паттерны — это паттерны, которые абстрагируют процесс инстанцирования или, иными словами, процесс порождения классов и объектов. Среди них выделяются следующие:

- Абстрактная фабрика (Abstract Factory)
- Строитель (Builder)
- Фабричный метод (Factory Method)
- Прототип (Prototype)
- Одиночка (Singleton)

#### Структурные паттерны:
Структурные паттерны - рассматривает, как классы и объекты образуют более крупные структуры - более сложные по характеру классы и объекты. К таким шаблонам относятся:

- Адаптер (Adapter)
- Мост (Bridge)
- Компоновщик (Composite)
- Декоратор (Decorator)
- Фасад (Facade)
- Приспособленец (Flyweight)
- Заместитель (Proxy)

#### Поведенческие паттерны:
Поведенческие паттерны - они определяют алгоритмы и взаимодействие между классами и объектами, то есть их поведение. Среди подобных шаблонов можно выделить следующие:

- Цепочка обязанностей (Chain of responsibility)
- Команда (Command)
- Интерпретатор (Interpreter)
- Итератор (Iterator)
- Посредник (Mediator)
- Хранитель (Memento)
- Наблюдатель (Observer)
- Состояние (State)
- Стратегия (Strategy)
- Шаблонный метод (Template method)
- Посетитель (Visitor)

### Что вам известно о шаблонах, которые применяются в ORM?

ORM (Object-Relation Mapping) – общее название для фреймворков, позволяющих автоматически связать базу данных с кодом. Они стараются скрыть существование базы данных настолько, насколько это возможно. Взамен, программисту дают возможность оперировать данными в базе через специальный интерфейс. Вместо построения SQL-запросов, программист вызывает простые методы, а всю остальную работу берёт на себя ORM.

### Напишите на PHP пример реализации паттерна Singleton.

````php
class Singleton {
  protected static $object = null;
  protected function __countruct()
  {
    //do something
  }
  public static function getInstance(): static
  {
    return (static::$object) ? static::$object : (static::$object = new static())     
  }
}
````

### Что такое Docker? Каков принцип его работы?
Docker — это платформа контейнеризации с открытым исходным кодом, с помощью которой можно автоматизировать создание приложений, их доставку и управление. Платформа позволяет быстрее тестировать и выкладывать приложения, запускать на одной машине требуемое количество контейнеров.

### Что такое LAMP / NAMP?
LAMP — это стек программного обеспечения, устанавливаемого на сервер и предназначенного для сайтов и веб-приложений. LAMP – это аббревиатура, она расшифровывается как: Linux, Apache, MySQL и PHP

### Расскажите о regexp.
Регуля́рные выраже́ния — формальный язык, используемый в компьютерных программах, работающих с текстом, для поиска и осуществления манипуляций с подстроками в тексте, основанный на использовании метасимволов. Для поиска используется строка-образец, состоящая из символов и метасимволов и задающая правило поиска.

### Расскажите о SSH-протоколе.
SSH (англ. Secure Shell — «безопасная оболочка») — сетевой протокол прикладного уровня, позволяющий производить удалённое управление операционной системой и туннелирование TCP-соединений (например, для передачи файлов).

### Что такое PDO?
PHP Data Objects — расширение для PHP, предоставляющее разработчику универсальный интерфейс для доступа к различным базам данных. PDO предлагает единые методы для работы с различными базами данных, хотя текст запросов может немного отличаться.

### Что такое PHP PEAR?
PEAR — это библиотека классов PHP с открытым исходным кодом, распространяемых через одноименный пакетный менеджер. В стандартную поставку PHP входит система управления классами PEAR, которая позволяет легко скачивать и обновлять их.

### Какие версии PHP до сих пор поддерживаются?
7.4 и выше

### В чем разница между GET и POST?
Основное отличие метода GET от POST в способе передачи данных. Запрос GET передает данные в URL в виде пар "имя-значение" (другими словами, через ссылку), а запрос POST передает данные в теле запроса

GET запросы могут кешироваться сервером 

### Чем отличаются операторы BREAK и CONTINUE?
BREAK останавливает цикл и передает управление коду за циклом
CONTINUE пропускает итерацию и продолжает цикл

### Есть ли разница между одинарными и двойными кавычками?
В PHP текст одинарной кавычки рассматривается как строковое значение, а текст двойной кавычки будет анализировать переменные, заменяя и обрабатывая их значение.


### Что такое Cookie и зачем они используются?
Cookies - это механизм хранения данных браузером удалённой машины для отслеживания или идентификации возвращающихся посетителей.

### Что нельзя хранить в Cookie и почему?
Любые данные, которые хранятся в cookie, посетитель может изменить. Соответственно, хранить в cookie можно только ID сессии,
какие-то ключи пользователя, настройки пользователя, и статистические данные.

## Git
### Какой командой добавить изменения?
git add

### Какой командой зафиксировать изменения?
git commit

### Какой командой отправить изменения в удаленный репозиторий?
git push

## Базы данных
### Что такое транзакция?
Транзакция — это набор операций по работе с базой данных (БД), объединенных в одну атомарную пачку.
Атомарность предполагает что либо все операции выполнятся, либо не выполнится ни одна из них (откат, rollback)

### Что такое нормализация?
Нормализация – это метод проектирования базы данных, который позволяет привести базу данных к минимальной избыточности

Избыточность данных – это когда одни и те же данные хранятся в базе в нескольких местах, так как в этом случае необходимо добавлять, изменять или удалять одни и те же данные в нескольких местах.

### Что такое денормализация? Для чего она нужна?
Денормализация — намеренное приведение структуры базы данных в состояние, не удовлетворяющее требованиям нормализации.

Денормализация обычно проводится путем добавления избыточных данных в таблицу, т.е. тех данных, которые по требованиям той или иной нормальной формы должны выноситься в отдельную таблицу.

Нужна для повышения производительности.

### Какие есть типы связей в базе данных?

- Многие ко многим.
- Один ко многим.
- Один к одному.

### Что означает утверждение о том, что СУБД поддерживает контроль ссылочной целостности связей?

Ссылочная целостность – это ограничение базы данных, гарантирующее, что ссылки между данными являются действительно правомерными и неповрежденными. Ссылочная целостность является фундаментальным принципом теории баз данных и проистекает из той идеи, что база данных должна не только сохранять данные, но и активно содействовать обеспечению их качества.

Ссылочная целостность – это предохранительное устройство системы управления базами данных, гарантирующее, что каждый внешний ключ соответствует первичному ключу. 
Например, номера заказчиков являются первичными ключами в файле заказчиков и внешними ключами в файле заказов. 
При удалении записи заказчика должны быть удалены соответствующие записи заказов; в противном случае они останутся без исходной связи. Если СУБД не проверяет этого, соответствующий механизм должен программироваться в приложении.

### Если используемая вами СУБД не поддерживает каскадные удаления для поддержки ссылочной целостности связей, что можно сделать для достижения аналогичного результата?
Реализовать этот механизм в приложении

### Что такое первичный и внешний ключи?
Внешний ключ — это столбец или комбинация столбцов, значения которых соответствуют Первичному ключу в другой таблице. Связь между двумя таблицами задается через соответствие Первичного ключа в одной из таблиц внешнему ключу во второй.

### В чем разница между первичным и уникальным ключами?

- В таблице может быть один первичный ключ, а в таблице может быть несколько уникальных ключей.
- Цель первичного ключа состоит в том, чтобы обеспечить целостность объекта, с другой стороны, цель уникального ключа – обеспечить уникальные данные.
- В первичном ключе индекс по умолчанию кластеризован, тогда как в уникальном ключе индекс по умолчанию не кластеризован
- Первичный ключ не допускает пустые столбцы, а уникальный – пустые.
- В первичном ключе дублирующиеся ключи не допускаются, тогда как в уникальном ключе, если одна или несколько частей ключа являются нулевыми, то дубликаты ключей допускаются.

### Какие есть типы JOIN и чем они отличаются?

#### INNER JOIN
Этот вид джойна выведет только те строки, если условие соединения выполняется (является истинным, т.е. TRUE). В запросах необязательно прописывать INNER – если написать только JOIN, то СУБД по умолчанию выполнить именно внутреннее соединение.

#### LEFT JOIN и RIGHT JOIN
Левое и правое соединения еще называют внешними. Главное их отличие от внутреннего соединения в том, что строка из левой (для LEFT JOIN) или из правой таблицы (для RIGHT JOIN) попадет в результаты в любом случае. Давайте до конца определимся с тем, какая таблица левая, а какая правая.
Левая таблица та, которая идет перед написанием ключевых слов LEFT | RIGHT| INNER JOIN, правая таблица – после них

#### FULL JOIN
Полное внешнее соединение.
Этот вид джойна вернет все строки из всех таблиц, участвующих в соединении, соединив между собой те, которые подошли под условие ON.

### Что такое курсоры в базах данных?

Курсор — ссылка на контекстную область памяти. В некоторых реализациях языка программирования SQL (Oracle, Microsoft SQL Server) — получаемый при выполнении запроса результирующий набор и связанный с ним указатель текущей записи. бы сказал, что курсор — это виртуальная таблица которая представляет собой альтернативное хранилище данных. При этом курсор, позволяет обращаться к своим данным, как к данным обычного массива.

### Что такое агрегатные функции SQL? Приведите несколько примеров.

В управлении базами данных функция агрегирования или функция агрегирования — это функция, в которой значения нескольких строк группируются вместе для формирования единого суммарного значения.

В MySQL есть следующие агрегатные функции:

- AVG: вычисляет среднее значение
- SUM: вычисляет сумму значений
- MIN: вычисляет наименьшее значение
- MAX: вычисляет наибольшее значение
- COUNT: вычисляет количество строк в запросе

### Что такое миграции?

Миграция - это именованный набор SQL-скриптов. Механизм миграций основан на последовательном применении SQL-скриптов для обновления структуры базы данных с помощью консольного приложения-мигратора.

### Расскажите о связи один к одному, один ко многим, многие ко многим.

Связь один к одному образуется, когда ключевой столбец (идентификатор) присутствует в другой таблице, в которой тоже является ключом либо свойствами столбца задана его уникальность (одно и тоже значение не может повторяться в разных строках).

В типе связей один ко многим одной записи первой таблицы соответствует несколько записей в другой таблице.

Если нескольким записям из одной таблицы соответствует несколько записей из другой таблицы, то такая связь называется «многие ко многим» и организовывается посредством связывающей таблицы.

### Назовите и объясните три любых агрегирующих метода.

- AVG: вычисляет среднее значение
- SUM: вычисляет сумму значений
- MIN: вычисляет наименьшее значение
- MAX: вычисляет наибольшее значение
- COUNT: вычисляет количество строк в запросе

### Зачем используют оператор группировки GROUP BY?

Оператор SQL GROUP BY служит для распределения строк - результата запроса - по группам, в которых значения некоторого столбца, по которому происходит группировка, являются одинаковыми. Группировку можно производить как по одному столбцу, так и по нескольким.

Часто оператор SQL GROUP BY применяется вместе с агрегатными функциями (COUNT, SUM, AVG, MAX, MIN). В этих случаях агрегатные функции служат для вычисления соответствующего агрегатного значения ко всему набору строк, для которых некоторый столбец - общий.

Если в результате запроса требуется вывести один столбец и по этому же столбцу производится группировка, то оператор GROUP BY просто выбирает уникальные значения и убирает дубликаты, то есть выполняет те же задачи, что и ключевое слово DISTINCT.

### В чем разница между WHERE и HAVING? Приведите примеры.

Главное отличие HAVING от WHERE в том, что в HAVING можно наложить условия на результаты группировки, потому что порядок исполнения запроса устроен таким образом, что на этапе, когда выполняется WHERE, ещё нет групп, а HAVING выполняется уже после формирования групп

### В чем разница между операторами DISTINCT и GROUP BY?

DISTINCT - получить уникальные строки (отличающиеся друг от друга любым отображаемым полем). Работает чуть быстрее.

GROUP BY - сгруппировать по какому-либо признаку, при этом можно использовать агрегатные функции SUM, AVG, MAX и т.д.

### Для чего нужны операторы UNION, INTERSECT, EXCEPT?

Оператор UNION используется для объединения результирующего набора из двух или более операторов SELECT. Каждый оператор SELECT в UNION должен иметь одинаковое количество столбцов. Столбцы также должны иметь похожие типы данных и в каждой инструкции SELECT быть в том же порядке.

Оператор SQL INTERSECT реализует операцию реляционной алгебры пересечение множеств, оператор SQL EXCEPT - разность множеств. В виде множеств выступают результаты единичных запросов.

### Опишите разницу типов данных DATETIME и TIMESTAMP.

DATETIME
Хранит время в виде целого числа вида YYYYMMDDHHMMSS, используя для этого 8 байтов. Это время не зависит от временной зоны. Оно всегда отображается при выборке точно так же, как было сохранено, независимо от того какой часовой пояс установлен в MySQL

TIMESTAMP
Хранит 4-байтное целое число, равное количеству секунд, прошедших с полуночи 1 января 1970 года по усреднённому времени Гринвича (т.е. нулевой часовой пояс, точка отсчёта часовых поясов). При получении из базы отображается с учётом часового пояса. Часовой пояс может быть задан в операционной системе, глобальных настройках MySQL или в конкретной сессии. Запомните, что сохраняется всегда количество секунд по UTC (универсальное координированное время, солнечное время на меридиане Гринвича), а не по локальному часовому поясу.

### Какие вы знаете движки таблиц и чем они отличаются?

#### InnoDB
В MySQL 8 подсистема хранения данных InnoDB используется по умолчанию и является наиболее широко применяемой из всех других доступных подсистем хранения. Подсистема InnoDB была выпущена вместе с MySQL 5.1 как плагин в 2008 году, и она рассматривается как подсистема хранения по умолчанию, начиная с версии 5.5 и выше. Поддержка подсистемы хранения InnoDB была перенята корпорацией Oracle в октябре 2005 года у финской компании Innobase Oy.

Таблицы InnoDB поддерживают ACID-совместимые фиксации транзакций, откат и возможности аварийного восстановления для защиты пользовательских данных. InnoDB также поддерживает блокировку на уровне строк, что помогает улучшить параллелизм и производительность. InnoDB хранит данные в кластеризованных индексах, чтобы уменьшить операции ввода-вывода для всех запросов SQL на выборку данных на основе первичного ключа. InnoDB также поддерживает ограничения внешнего ключа, которые обеспечивают лучшую целостность данных в базе данных. Максимальный размер таблицы InnoDB может масштабироваться до 256 Тб, что должно быть вполне достаточным во многих случаях использования больших данных.

#### MyISAM
Подсистема хранения данных MyISAM использовалась по умолчанию для MySQL вплоть до версии 5.5 1. В отличие от InnoDB, таблицы подсистемы хранения данных MylSAM не поддерживают ACID-совместитмость. Таблицы MylSAM поддерживают только блокировку уровня таблицы, поэтому таблицы MyISAM небезопасны для транзакций. Таблицы MyISAM оптимизированы для сжатия и скорости. MyISAM обычно используется, когда вам нужно иметь в основном операции чтения с минимальными транзакционными данными. Максимальный размер таблицы MyISAM может достигать 256 Тб, что помогает в таких случаях, как анализ данных.

Подсистема хранения данных MyISAM поддерживает полнотекстовое индексирование, которое может помочь в сложных операциях поиска. С помощью полнотекстовых индексов можно индексировать данные, хранящиеся в типах данных BLOB и TEXT.

Из-за низких накладных расходов MyISAM использует более простую структуру, которая обеспечивает хорошую производительность; однако это не сильно помогает для получения хорошей производительности, когда есть потребность в лучшем параллелизме и случаях использования, которые не нуждаются в тяжелых операциях чтения. Наиболее распространенной проблемой производительности MyISAM является блокировка таблицы, которая может задерживать ваши параллельные запросы в очереди. Это происходит, когда она блокирует таблицу для любой другой операции до тех пор, пока более ранняя операция не будет выполнена.

Таблица MyISAM не поддерживает транзакции и внешние ключи. Судя по всему, из-за этих ограничений вместо таблиц MyISAM теперь системные таблицы схемы MySQL 8 используют таблицы InnoDB.


#### Memory

Подсистема хранения в памяти (подсистема оперативного хранения данных) обычно называется подсистемой хранения данных на основе кучи. Она используется для чрезвычайно быстрого доступа к данным. Эта подсистема хранения содержит данные в оперативной памяти, поэтому ей не нужны операции ввода- вывода. Поскольку она хранит данные в оперативной памяти, все данные теряются при перезапуске сервера. Такая подсистема в основном используется для временных таблиц или таблицы подстановки. Эта подсистема поддерживает блокировку на уровне таблицы, которая ограничивает параллелизм с высокой частотой записи.

Оперативная таблица хранит данные в оперативной памяти, которая имеет очень ограниченный объем; если вы попытаетесь записать слишком много данных в оперативную таблицу, она начнет свопить данные на диск, и тогда вы потеряете преимущества подсистемы хранения данных в памяти.
Оперативные таблицы не поддерживают типы данных TEXT и BLOB; такие типы данных могут не потребоваться, так как таблицы имеют ограниченную емкость.
Эта подсистема хранения может использоваться для кеширования результатов; таблицы поиска, например, или почтовые индексы и названия штатов.
Оперативные таблицы поддерживают индексы на основе B-дерева и хеш-индексы.

#### Archive

Эта подсистема хранения данных используется для хранения больших объемов исторических данных без каких-либо индексов. Архивные таблицы не имеют ограничений по объему хранимых данных. Архивная подсистема хранения данных оптимизирована для операций с высокой частотой вставки, а также поддерживает блокировку на уровне строк. Такие таблицы хранят данные в сжатом и малом форматах. Архивная подсистема не поддерживает операции DELETE или UPDATE; она разрешает только операции INSERT, REPLACE и SELECT.

#### Blackhole

Эта подсистема хранения данных принимает данные, но их не сохраняет. Вместо сохранения данных она отбрасывает (уничтожает) их после каждой вставки.

Эта подсистема хранения полезна для репликации с большим количеством серверов. Подсистема хранения данных Blackhole работает в качестве фильтрующего сервера между ведущим и ведомым серверами, который не хранит никаких данных, но который применяет только правила replicate-do-* и replicate-ignore-* и пишет двоичные журналы. Эти двоичные журналы используются для выполнения репликации на ведомых серверах.

#### CSV

Подсистема хранения данных CSV хранит данные в файлах в формате .csv, используя формат с разделением значений запятыми. Эта подсистема извлекает данные из базы данных и копирует их в .csv. Если вы создаете CSV-файл из электронной таблицы и копируете его на сервер папок данных MYSQL, она может читать данные с помощью запроса SELECT на выборку данных. Аналогичным образом, если вы записываете данные в таблицу, внешняя программа может их прочитать из CSV-файла. Эта подсистема хранения данных используется для обмена данными между программным обеспечением или приложениями. Таблица CSV не поддерживает индексирование и разделение. Чтобы избежать ошибок при создании таблицы, все столбцы в подсистеме хранения данных CSV должны быть определены с атрибутом NOT NULL.


#### Merge

Эта подсистема хранения данных также называется подсистемой хранения MRG_Myisam. Эта подсистема хранения объединяет все данные в одну таблицу MyISAM и использует ее для ссылки на единственное представление. В таблицах объединения/слияния все столбцы перечисляются в том же порядке. Эти таблицы хороши для сред объединения баз данных.

Как правило, эта подсистема используется для управления таблицами, связанными с журналом регистрации событий. В отдельных таблицах MyISAM можно задавать различные месяцы журналов и объединять эти таблицы с помощью подсистемы хранения данных MERGE.

Таблицы MyISAM имеют ограничение по объему хранения для операционной системы, но коллекция таблиц MyISAM (MERGE) не имеет таких ограничений. Таким образом, использование подсистемы MERGE позволит вам разделять данные на многочисленные таблицы MyISAM, что может помочь в преодолении ограничений по объему хранения.

С помощью подсистемы MERGE трудно выполнять разделение, следовательно, таблицами MERGE оно не поддерживается, и мы не можем реализовать раздел на таблице MERGE или любой таблице MyISAM.

#### Federated

Подсистема интегрированного хранения данных FEDERATED позволяет создавать одну базу данных на нескольких физических серверах. Она открывает клиентское соединение с другим сервером и выполняет запросы к таблице, получая и отправляя строки по мере необходимости. Первоначально она рекламировалась как конкурентная функциональность, которая поддерживала многие корпоративные проприетарные серверы баз данных, такие как Microsoft SQL Server и Oracle, но это всегда было натяжкой, мягко говоря. Хотя казалось, что в ней задействовалось много гибкости и хитрых приемов, она оказалась источником многих проблем и по умолчанию деактивирована. Однако мы можем ее активировать, запустив двоичный файл сервера MySQL с параметром --federated.


#### NDB Cluster

NDB Cluster (или просто NDB) - это подсистема хранения прямо в оперативной памяти, обеспечивающая высокую доступность и сохраняемость данных.

Кластерная подсистема хранения данных NDB Cluster может конфигурироваться с помощью ряда параметров аварийного переключения и балансировки нагрузки, но проще всего начать с подсистемы хранения на уровне кластера. NDB Cluster использует подсистему хранения NDB и содержит полный набор данных, который зависит только от других наборов данных, доступных в кластере.

Кластерная часть NDB Cluster настроена независимо от серверов MySQL. В NDB Cluster каждая часть кластера считается узлом.

Кластерный движок - данные автоматически разделяются и реплицируются по различным машинам, именуемым - дата узлы. Применяется для приложений, которые требуют высокой производительности с наивысшей степенью доступности. NDB хорошо работает на системах требующих высокой отдачи на операциях чтения. Для "тяжелых" приложений требующих активной записи в конкурирующей среде рассмотрите вариант с InnoDB.

### Какие способы оптимизации производительности баз данных знаете?

#### Оптимизация запросов
В большинстве случаев проблемы с производительностью вызваны низкой производительностью SQL-запросов. При попытке оптимизировать эти запросы вы столкнетесь со многими дилеммами, например, использовать ли IN или EXISTS, писать ли подзапрос или объединение. Хотя вы можете платить хорошие деньги за консультационные услуги, вы также можете ускорить запросы SQL с помощью оптимизаторов запросов, которые ускорят запрос и объяснят рекомендации, чтобы вы могли учиться на будущее.



#### Создать оптимальные индексы
При правильной индексации можно оптимизировать продолжительность выполнения запроса и повысить общую производительность базы данных. Индексы достигают этого, внедряя структуру данных, которая помогает поддерживать порядок и облегчает поиск информации; в основном, индексирование ускоряет процесс поиска данных и делает его более эффективным, тем самым экономя ваше время (и вашу систему) и усилия.


#### Более мощный процессор
Чем лучше ваш процессор, тем быстрее и эффективнее будет ваша база данных. Поэтому, если ваша база данных работает не так, вы должны рассмотреть возможность обновления процессорного модуля более высокого класса; чем мощнее ваш процессор, тем меньше нагрузка при работе с несколькими приложениями и запросами. Кроме того, при оценке производительности ЦП важно отслеживать все аспекты производительности ЦП, в том числе время готовности ЦП (которое может рассказать вам о случаях, когда ваша система пыталась использовать ЦП, но не смогла, поскольку все ресурсы ЦП были слишком заняты или иным образом заняты).



#### Больше памяти
Подобно тому, как недостаточно мощный процессор может повлиять на эффективность базы данных, так же как и нехватка памяти. В конце концов, когда в базе данных недостаточно памяти для выполнения запрашиваемой работы, производительность базы данных по понятным причинам пойдет на спад. По сути, наличие большего объема памяти поможет повысить эффективность системы и общую производительность. Хороший способ проверить, нужно ли вам больше памяти, – посмотреть, сколько ошибок в вашей системе имеет страница; Если количество сбоев велико (например, в тысячах), это означает, что вашим хостам не хватает (или, возможно, полностью не хватает) доступного пространства памяти. Следовательно,

Кроме того, вы можете рассмотреть вопрос об увеличении объема памяти, используемой MySQL. Мы рекомендуем разрешить ему выделять 70% общей памяти (при условии, что база данных является единственным приложением на этом сервере). Вы можете изменить объем памяти, выделенной для базы данных, используя ключ innodb_buffer_pool_size в файле конфигурации MySQL, my.cnf.


#### Дефрагментация данных
Если у вас проблемы с медленной базой данных, другим возможным решением является дефрагментация данных. Когда в базу данных записывается много записей и время идет, записи фрагментируются во внутренних файлах данных MySQL и на самом диске. Дефрагментация диска позволит сгруппировать соответствующие данные, поэтому операции, связанные с вводом/выводом, будут выполняться быстрее, что напрямую повлияет на общую производительность запросов и базы данных. Кроме того, на некотором связанном примечании также важно иметь достаточно дискового пространства вообще, работая с базой данных; если вы действительно хотите оптимизировать производительность базы данных, обязательно используйте дефрагментацию диска, сохраняя при этом достаточно свободного дискового пространства для вашей базы данных.



#### Типы дисков
Для извлечения результатов даже одного запроса могут потребоваться миллионы операций ввода-вывода с диска, в зависимости от объема данных, к которым запрос должен получить доступ для обработки, и в зависимости от объема данных, возвращаемых из запроса. Таким образом, тип дисков на вашем сервере может сильно повлиять на производительность ваших SQL запросов. Работа с SSD-дисками может значительно повысить общую производительность базы данных и, в частности, производительность SQL-запросов.



#### Версия базы данных
Другим важным фактором производительности базы данных является версия MySQL, которую вы в настоящее время развертываете. Обновление последней версии базы данных может существенно повлиять на общую производительность базы данных. Возможно, что один запрос может работать лучше в старых версиях MySQL, чем в новых, но если посмотреть на общую производительность, новые версии, как правило, работают лучше.


### Что такое партиционирование, репликация и шардинг?

#### Партиционирование (partitioning)
Партиционирование — это разбиение таблиц, содержащих большое количество записей, на логические части по неким выбранным администратором критериям. Партиционирование таблиц делит весь объем операций по обработке данных на несколько независимых и параллельно выполняющихся потоков, что существенно ускоряет работу СУБД. Для правильного конфигурирования параметров партиционирования необходимо, чтобы в каждом потоке было примерно одинаковое количество записей.

Например, на новостных сайтах имеет смысл партиционировать записи по дате публикации, так как свежие новости на несколько порядков более востребованы и чаще требуется работа именно с ними, а не со всех архивом за годы существования новостного ресурса.

#### Репликация (replication)
Репликация — это синхронное или асинхронное копирование данных между несколькими серверами. Ведущие сервера называют мастерами (master), а ведомые сервера — слэйвами (slave). Мастера используются для изменения данных, а слэйвы — для считывания. В классической схеме репликации обычно один мастер и несколько слэйвов, так как в большей части веб-проектов операций чтения на несколько порядков больше, чем операций записи. Однако в более сложной схеме репликации может быть и несколько мастеров.

Например, создание нескольких дополнительных slave-серверов позволяет снять с основного сервера нагрузку и повысить общую производительность системы, а также можно организовать слэйвы под конкретные ресурсоёмкие задачи и таким образом, например, упростить составление серьёзных аналитических отчётов — используемый для этих целей slave может быть нагружен на 100%, но на работу других пользователей приложения это не повлияет.

#### Шардинг (sharding)
Шардинг — это прием, который позволяет распределять данные между разными физическими серверами. Процесс шардинга предполагает разнесения данных между отдельными шардами на основе некого ключа шардинга. Связанные одинаковым значением ключа шардинга сущности группируются в набор данных по заданному ключу, а этот набор хранится в пределах одного физического шарда. Это существенно облегчает обработку данных.

Например, в системах типа социальных сетей ключом для шардинга может быть ID пользователя, таким образом все данные пользователя будут храниться и обрабатываться на одном сервере, а не собираться по частям с нескольких.

### Чем отличаются SQL от NoSQL базы данных?

В SQL-системах данные представляются в формате таблиц, тогда как в NoSQL — в формате 
#### документов

Данные, которые представлены парами ключ-значение, могут сжиматься в виде хранилища документов. Реализация похожа на хранилище «ключ-значение», но разница в том, что в документоориентированной БД хранимые значения (документы) характеризуются определённой структурой и кодировкой данных (XML, JSON, BSON).

На сегодняшний день наиболее популярными документоориентированными СУБД являются Couchbase и MongoDB.

#### графов

Хранилище на основе графов — это сетевая NoSQL БД, использующая для отображения и хранения данных узлы и ребра. В ней вы не найдете строгого SQL-формата либо представления таблиц и колонок — вместо этого применяется гибкое графическое представление, прекрасно подходящее для решения проблем с масштабируемостью. Пример соответствующей СУБД — Neo4J.

Графовые структуры применяются совместно с ребрами, узлами и свойствами — таким образом обеспечивается безиндексная смежность. В случае применения графового хранилища вы сможете легко преобразовать данные из одной модели в другую.

такие БД используют для представления данных узлы и ребра;
между собой узлы связаны определенным отношениями, которые представлены ребрами;
узлы и отношения характеризуются рядом свойств.

Как это используется на практике?
Вспомните любой из рейтингов «Рекомендовано вам», которые есть на многих сайтах. Как правило, они формируются на основании оценки продукта пользователем. Как раз для такого случая и подходят графовые базы данных.

#### пар «ключ-значение» 

Такие БД обычно используют хеш-таблицу, где присутствуют уникальный ключ и указатель на конкретный объект данных. Ключ бывает синтетическим либо автоматически сгенерированным, а значение бывает представлено JSON, строкой, блобом (Binary Large Object) и т. д.

Говоря о БД «ключ-значение», стоит упомянуть о таком понятии, как блок (bucket) — это логическая группа ключей, не группирующих данные физически. При этом в различных блоках бывают идентичные ключи. За счёт кеширующих механизмов, работающих на основе маппингов, производительность базы данных существенно вырастает. Дабы прочитать значение, надо знать и ключ, и блок, т. к. на деле ключ является хешем (блок, плюс ключ).

Несмотря на то, что БД типа «ключ-значение» неплохо себя зарекомендовали в определённых ситуациях, недостатки у них, разумеется, тоже присутствуют. Например, модель не предоставляет стандартные возможности для баз данных — допустим, атомарность транзакций либо согласованность данных при одновременном исполнении нескольких транзакций. То есть такие возможности должны предоставляться непосредственно самим приложением. Есть и второй существенный недостаток: когда происходит увеличение объёмов данных, поддерживать уникальные ключи становится проблемно. И чтобы эту проблему решить, надо каким-нибудь образом усложнять процесс генерации строк, дабы они оставались уникальными среди огромного набора ключей.

Redis, Memcache

#### wide-column-хранилищ (Колоночная база данных NoSQL)

В колоночных БД данные хранятся в ячейках, которые сгруппированы не в строки, а в колонки. Эти колонки логически группируются в соответствующие колоночные семейства, которые могут состоять, по сути, из неограниченного числа колонок (колонки могут создаваться либо во время работы программы, либо во время определения схемы). Запись и чтение осуществляются с применением колонок, а не строк.

Если сравнивать эту базу с хранением данных в строках, как это принято в большинстве реляционных БД, то у хранения в колонках есть свои плюсы. Например, быстрый поиск/доступ и агрегация данных. SQL-базы хранят каждую строку в виде непрерывной записи на диске, то есть различные строки хранятся в различных местах на диске. В случае с колоночной структурой, БД хранят все ячейки, которые относятся к колонке, в виде непрерывной записи — это и делает выполнение операций по поиску и доступу быстрее.

Простой пример: если мы захотим получить список заголовков нескольких миллионов статей, то при использовании SQL-баз это станет весьма трудоёмкой задачей, ведь для извлечения заголовков понадобится проходить по каждой записи. В случае с NoSQL мы сможем получить все заголовки посредством всего одной операции доступа к диску.

Колоночное семейство представляет собой структуру, которая может без проблем группировать колонки и суперколонки.
Ключ является постоянным именем записи. Ключи могут иметь различное число колонок, следовательно, БД способна расширяться неравномерно.
Есть термин пространства ключей. Это пространство определяет самый внешний уровень организации, обычно это имя приложения или имя БД.
Колонка характеризуется упорядоченным списком элементов, которые представляют собой кортежи со значениями и именами.

Наиболее известные примеры колоночных БД — ClickHouse, Google BigTable и HBase с Cassandra.

### Какие типы данных есть в MySQL?

MySQL поддерживает типы данных SQL нескольких видов: числовые, типы даты и времени, строковые (символьные и байтовые) типы, пространственные типы и JSON типы данных.

### Разница между JOIN и UNION?

UNION помещает строки из запросов друг за другом, а JOIN делает декартово произведение и подмножества - это совершенно разные операции.

### Что такое индексы? Как они влияют на время выполнения SELECT, INSERT?

Индексы – это специальные таблицы, которые могут быть использованы поисковым двигателем базы данных (далее – БД), для ускорения получения данных. Необходимо просто добавить указатель индекса в таблицу. Индекс в БД крайне схож с индексом в конце книги.

Индекс помогает ускорить запросы на получение данных SELECT WHERE, но замедляет процесс добавления и изменения записей (INSERT, UPDATE). Индексы могут быть добавлены или удалены без влияния на сами данные.

### Что такое хранимые процедуры, функции и триггеры в MySQL? Для чего они? Приведите примеры использования.

Функции не могут возвращать несколько результирующих наборов. Хранимая процедура может сформировать и вернуть несколько результирующих наборов данных

Хранимые процедуры представляют собой набор команд SQL, которые могут компилироваться и храниться на сервере. Таким образом, вместо того, чтобы хранить часто используемый запрос, клиенты могут ссылаться на соответствующую хранимую процедуру. Это обеспечивает лучшую производительность, поскольку данный запрос должен анализироваться только однажды и уменьшается трафик между сервером и клиентом. Концептуальный уровень можно также повысить за счет создания на сервере библиотеки функций.

Триггер представляет собой хранимую процедуру, которая активизируется при наступлении определенного события. Например, можно задать хранимую процедуру, которая срабатывает каждый раз при удалении записи из транзакционной таблицы - таким образом, обеспечивается автоматическое удаление соответствующего заказчика из таблицы заказчиков, когда все его транзакции удаляются.

### Как организовать сохранность вложенных категорий в MySQL?

Можно использовать nullable столбец parent_id, указывающий на ID родительской категории, если она есть

## Laravel
### Какие есть связи и как они реализуются в Laravel?

Отношения Eloquent определяются как методы в классах модели Eloquent. Поскольку отношения реализованы поверх построителей запросов, использование отношений как методов (к примеру, не ->posts, а ->posts()) обеспечивает возможность создания цепочек методов и запросов.

#### Один к одному
#### Один ко многим
#### Определение обратной связи Один ко многим
#### Один из многих
#### Один через отношение
#### Многие через отношение

hasManyThrough

#### Отношения Многие ко многим
#### Полиморфные отношения
#### Один к одному (полиморфное)

Полиморфное отношение «один-к-одному» похоже на типичное «один-к-одному» отношение; однако, дочерняя модель может принадлежать более чем к одному типу моделей с помощью одной ассоциации. Например, блог Post и User могут иметь полиморфное отношение С моделью Image. Использование полиморфного «один-к-одному» отношения позволяет вам иметь единую таблицу уникальных изображений, которые могут быть связаны с постами и пользователями.

#### Один ко многим (полиморфное)
#### Один из многих (полиморфное)
#### Многие ко многим (полиморфное)
#### Динамические отношения

Вы можете использовать метод resolveRelationUsing для определения отношений между моделями Eloquent во время выполнения скрипта. Хотя обычно это не рекомендуется для нормальной разработки приложений, но иногда это может быть полезно при разработке пакетов Laravel.

### Что такое полиморфные связи, как они работают?

Полиморфные отношения позволяют дочерней модели принадлежать более чем к одному типу модели с использованием одной ассоциации. Например, представьте, что вы создаете приложение, которое позволяет пользователям делиться постами и видео в блогах. В таком приложении модель Comment может принадлежать как к моделям Post, так и к Video.

### Что такое middleware? Зачем это? На каком этапе выполняется?

Типичная обработка маршрута Laravel проходит через определенные этапы обработки запроса, а middleware - один из тех уровней, которым приложение должно пройти.

Laravel Middleware (посредник) выполняет функцию промежуточного звена между запросом и ответом. Это тип механизма фильтрации. Например, Laravel включает Middleware, которое проверяет подлинность пользователя приложения. Если пользователь аутентифицирован, он будет перенаправлен на главную страницу, в противном случае он будет перенаправлен на страницу входа в систему.

## Composer
### Что такое Composer?

Composer — это пакетный менеджер уровня приложений для языка программирования PHP, который предоставляет средства по управлению зависимостями в PHP-приложении.

### Чем отличается require от require-dev?

В require добавляются зависимости, которые необходимы для работы пакета. В require-dev добавляются зависимости, которые нужны для разработки самого пакета. Например, phpunit/phpunit