## PHP 7.4. Что нового

### Свойства класса теперь поддерживают объявления типов.

````php
class User {
public int $id;
public string $name;
}
````

### Стрелочные функции
Стрелочные функции - это сокращённая запись для определения функций с неявной привязкой родительской области видимости по значению.

````php
$factor = 10;
$nums = array_map(fn($n) => $n * $factor, [1, 2, 3, 4]);
// $nums = array(10, 20, 30, 40);
````


Стрелочные функции появились в PHP 7.4, как более лаконичный синтаксис для анонимных функций.

И анонимные, и стрелочные функции реализованы с использованием класса Closure.

Основной вид записи стрелочных функций: fn (argument_list) => expr.

Стрелочные функции поддерживают те же возможности, что и анонимные функции, за исключением того, что использование переменных из родительской области всегда выполняется автоматически.

Когда переменная, используемая в выражении, определена в родительской области, она будет неявно захвачена по значению. В следующем примере функции $fn1 и $fn2 ведут себя одинаково.


Пример #1 Стрелочные функции захватывают переменные по значению автоматически

````php
$y = 1;

$fn1 = fn($x) => $x + $y;
// эквивалентно использованию $y по значению:
$fn2 = function ($x) use ($y) {
return $x + $y;
};

var_export($fn1(3));

4
````


Это также работает во вложенных стрелочных функциях:

Пример #2 Стрелочные функции захватывают переменные по значению автоматически, даже когда они вложены

````php
$z = 1;
$fn = fn($x) => fn($y) => $x * $y + $z;
// Выведет 51
var_export($fn(5)(10));
````

Подобно анонимным функциям, синтаксис стрелочных функций допускает произвольные сигнатуры функций, включая типы параметров и возвращаемых значений, значения по умолчанию, переменные, а также передачу и возврат по ссылке. Ниже приведены корректные примеры стрелочных функций:

````php
fn(array $x) => $x;
static fn(): int => $x;
fn($x = 42) => $x;
fn(&$x) => $x;
fn&($x) => $x;
fn($x, ...$rest) => $rest;
````

Стрелочные функции используют привязку переменных по значению. Это примерно эквивалентно выполнению use($x) для каждой переменной $x, используемой внутри стрелочной функции. Привязка по значению означает, что невозможно изменить какие-либо значения из внешней области. Вместо этого можно использовать анонимные функции для привязок по ссылкам.

````php
$x = 1;
$fn = fn() => $x++; // Ничего не изменит
$fn();
var_export($x);  // Выведет 1
````

Анонимные функции, также известные как замыкания (closures), позволяют создавать функции, не имеющие определённых имён. Они наиболее полезны в качестве значений callable-параметров, но также могут иметь и множество других применений.

Анонимные функции реализуются с использованием класса Closure.


### Ограниченная ковариация возвращаемого типа и контравариантность типа аргумента ¶
Следующий код теперь будет работать:

````php
class A {}
class B extends A {}

class Producer {
public function method(): A {}
}
class ChildProducer extends Producer {
public function method(): B {}
}
````

Полная поддержка вариантности доступна только при использовании автозагрузки. Внутри одного файла могут быть только нециклические ссылки, поскольку все классы должны быть определены, перед тем как на них ссылаться.

### Присваивающий оператор объединения с null

````php
$array['key'] ??= computeDefault();
// примерно то же самое
if (!isset($array['key'])) {
$array['key'] = computeDefault();
}
````

### Распаковка внутри массивов

````php
$parts = ['apple', 'pear'];
$fruits = ['banana', 'orange', ...$parts, 'watermelon'];
// ['banana', 'orange', 'apple', 'pear', 'watermelon'];

````

### Разделитель в числовых литералах
Теперь в числовых литералах между знаками могут быть символы подчёркивания.

````php
6.674_083e-11; // число с плавающей точкой
299_792_458;   // десятичное число
0xCAFE_F00D;   // шестнадцатеричное число
0b0101_1111;   // двоичное число
````

### Слабые ссылки
Слабые ссылки позволяют программисту сохранить ссылку на объект, которая не помешает сборщику мусора удалить этот объект.

Класс WeakReference предоставляет способ доступа к объекту, не влияя при этом на количество ссылок на него, таким образом сборщик мусора сможет освободить этот объект.
Объект класса WeakReference не может быть сериализован.

````php
$obj = new stdClass;
$weakref = WeakReference::create($obj);
var_dump($weakref->get());
unset($obj);
var_dump($weakref->get());
````


### Обработка исключений из метода __toString()
Выбрасывание исключений из метода __toString() теперь разрешено. Ранее это приводило к фатальной ошибке. Существующие отлавливаемые фатальные ошибки при преобразовании объекта в строку будут доступны в виде исключений класса Error.

### CURL
Помимо обычных имён файлов, класс CURLFile теперь поддерживает потоковые обёртки, если модуль был собран с версией libcurl >= 7.56.0.

### Хеширование
Добавлен хеш crc32c, использующий полином Кастаноли. Эта реализация алгоритма CRC32 используется системами хранения, такими как iSCSI, SCTP, Btrfs и ext4.

### Многобайтовые строки
Добавлена функция mb_str_split(), которая выполняет, то же, что и str_split(), но работает с кодовыми точками, а не с байтами.

### OPcache
Добавлена поддержка предварительной загрузки кода.

### PDO
Имя пользователя и пароль теперь можно указать как часть DSN для драйверов mysql, mssql, sybase, dblib, firebird и oci. Ранее поддержка этого была только для драйвера pgsql. Если имя пользователя/пароль указаны и в конструкторе и в DSN, то конструктор будет иметь приоритет.

Также теперь можно экранировать вопросительные знаки в SQL-запросах, чтобы они не воспринимались как именованные параметры. Использование ?? отправит один знак вопроса в базу данных, и, например, в случае использования PostgreSQL, будет использован оператор проверки существования ключа в JSON (?).

### strip_tags() с массивом имён тегов
Функция strip_tags() теперь также принимает массив разрешённых тегов: вместо strip_tags($str, '<a><p>') теперь можно написать strip_tags($str, ['a', 'p']).

### Пользовательская сериализация объектов
Добавлен новый механизм сериализации пользовательских объектов, использующий два новых магических метода: __serialize и __unserialize.

````php
// Возвращает массив, содержащий все необходимое состояние объекта.
public function __serialize(): array;

// Восстанавливает состояние объекта из указанного массива данных.
public function __unserialize(array $data): void;


````

Новый механизм сериализации заменяет интерфейс Serializable, который в будущем будет объявлен устаревшим.

### Функции слияния массивов без аргументов
Функции array_merge() и array_merge_recursive() теперь могут вызываться без каких-либо аргументов, и тогда они возвратят пустой массив. Это полезно в сочетании с оператором расширения, например, array_merge(...$arrays).

### Функция proc_open()
proc_open() теперь принимает массив вместо строки для выполнения команды. В этом случае процесс будет открыт напрямую (без командной оболочки), а PHP экранирует любой необходимый аргумент.

````php
proc_open(['php', '-r', 'echo "Привет, мир\n";'], $descriptors, $pipes);
````

Функция proc_open() теперь поддерживает дескрипторы redirect и null.

````php
// То же самое, что и 2>&1 в командной оболочке
proc_open($cmd, [1 => ['pipe', 'w'], 2 => ['redirect', 1]], $pipes);
// То же самое, что и 2>/dev/null или 2>nul в командной оболочке
proc_open($cmd, [1 => ['pipe', 'w'], 2 => ['null']], $pipes);
````

