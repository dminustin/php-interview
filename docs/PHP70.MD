# Версии PHP
## Новое в php 7.0

### Войны за производительность, PHP 7 vs. PHP 5

Практически все обновления привносили небольшие улучшения производительности. Однако на этот раз производительность PHP, по сравнению с более ранними версиями, выросла куда более существенно, став одной из наиболее привлекательных особенностей PHP 7. Это было частью проекта “PHPNG” (“php new generation” или “php нового поколения”, — прим. переводчика), затронувшего собственно сам Zend Engine.

Рефакторинг внутренних структур данных и добавление дополнительного этапа перед компиляцией кода в виде абстрактного синтаксического дерева — Abstract Syntax Tree (AST), привели к превосходной производительности и более эффективному распределению памяти. Цифры сами по себе выглядят многообещающе — тесты, выполненные на реальных приложениях показывают, что PHP 7 в среднем вдвое быстрее PHP 5.6, а также использует на 50% меньше памяти вовремя обработки запросов, что делает PHP 7 сильным соперником для компилятора HHVM JIT от Facebook.

PHP 7 выглядит знакомо, но он “заточен” под производительность. Усовершенствованный Zend Engine и итоговый прирост производительности привели к огромной разнице между ним и предыдущей версией.

Уменьшение потребления памяти позволяет более слабым компьютерам лучше обрабатывать запросы, предоставляя возможность выстраивания микросервисов вокруг PHP. Внутренние изменения, в частности реализация AST, также открывает возможности для будущих оптимизаций, которые могут ещё больше увеличить производительность. Новая собственная реализация JIT-компилятора разработана с намерением развития в будущих версиях.


### Группировка объявлений импорта
Теперь мы можем группировать объявления импорта классов, находящихся в одном пространстве имён, в одной строке.

````php
use Framework\Module\{Foo, Bar, Baz};
````

````php
use Framework\Module{
Foo,
Bar,
Baz
};
````

### Null-коалесцентный оператор
````php
$bar = $foo ?? 'default';
````

````php
$bar = $foo ?? $baz ?? 'default';
````

### Оператор “космический корабль”
Оператор “космический корабль” <=> позволяет проводить трехуровневое сравнение двух значений, позволяя понимать не только их равенство или неравенство, но и то, которое из них больше при неравенстве, возвращая 1,0 или -1.
В этом случае мы можем предпринимать различные действия в зависимости от того, как различаются значения:

````php
switch ($bar <=> $foo) {
case 0:
    echo '$bar и $foo равны';
case -1:
    echo '$foo больше';
case 1:
    echo '$bar больше';
}
````

### Типы скалярных параметров и подсказки (hints) по возвращаемым типам
В PHP 7 расширили ранее существовавшее объявление параметров в методах (классах, интерфейсах и массивах) путем добавления четырех скалярных типов — целого (int), с плавающей запятой (float), логического (bool) и строкового (string) в качестве возможного типа параметра.

Кроме того, опционально мы можем указать тип результата, возвращаемого функцией или методом. Поддерживаются типы bool, int, float, string, array, callable, имя класса или интерфейса и parent (для методов класса).

````php
class Calculator
{
// объявляем, что параметры имеют целый тип integer
    public function addTwoInts(int $x, int $y): int { 
// явно объявляем, что метод возвращает целое
        return $x + $y;
    }
}
````

Объявление типов позволит строить прозрачные приложения, избегая передачи и возврата неверных значений при работе с функциями. Другие плюсы — появление анализаторов статического кода и IDE, предлагающих более ясное отображение кода при отсутствии документирующих примечаний DocBlocks.

Поскольку PHP слабо типизированный язык, некоторые значения параметров и возвращаемых типов будут приводиться исходя из контекста. Если мы передаем значение “3” в функцию, имеющую объявленный параметр типа int, интерпретатор будет рассматривать его как целое и не сгенерирует ошибку. Если вас не устраивает такое поведение, вы можете работать в строгом режиме — strict mode — путем добавки соответствующей директивы.

````php
declare(strict_types=1);
````

Она устанавливается отдельно для каждого файла

### Исключения движка

Ошибки, такие как вызов несуществующего метода, теперь не остановят скрипт, вместо этого будет сгенерировано исключение, которое можно обработать в блоке try catch, что явно улучшает обработку ошибок в вашем приложении. Это важно для некоторых типов приложений, серверов и демонов, поскольку фатальные ошибки, в противном случае, вполне могли привести к необходимости их рестарта. Тесты в PHPUnit также должны стать более удобными в использовании, поскольку фатальные ошибки могли уронить весь тестировочный проект. Исключения, в отличие от ошибок, могут быть обработаны для каждого теста отдельно.

### Анонимные классы
Анонимные классы — двоюродные братья анонимных функций, которые вы могли использовать при создании функциональности коротких и ясных объектов. Анонимные классы легко создаются и используются так же, как и обычные объекты. Вот пример из документации.

До PHP 7:
````php
class MyLogger {
  public function log($msg) {
    print_r($msg . "\n");
  }
}

$pusher->setLogger( new MyLogger() );
````

Использование анонимного класса:
````php
$pusher->setLogger(new class {
  public function log($msg) {
    print_r($msg . "\n");
  }
});
````

Анонимные классы полезны при тестировании юнитами, в частности при мокинге (имитации поведения реального объекта — прим. переводчика) при тестировании объектов и сервисов. Их наличие позволит нам избежать использования больших мокинг-библиотек и фреймворков путем создания простого объекта, поддерживающего интерфейс, который мы можем использовать для мокинга.


### Функции CSPRNG

Две новых функции для генерации крипографически безопасной строки и целых. Первая возвращает случайную строку длиной $len:
````php
random_bytes(int $len);
````

Вторая возвращает число в диапазоне $min… $max.
````php
random_int(int $min, int $max);
````

### Синтаксис Escape-кода для Unicode
В отличие от многих других языков, до PHP версии 7, в PHP не было способа указать в строке escape-последовательность для Unicode символа. Теперь с помощью escape-последовательности \u можно генерировать такие символы с помощью их кода из набора UTF-8. Это лучше, чем непосредственная вставка символов, лучше контролируются невидимые символы и символы, имеющие графическое отображение отличное от значения:

````php
echo "\u{1F602}"; // выводит смайлик
````

### Обновленные генераторы
Генераторы в PHP тоже получили несколько приятных новых возможностей. Теперь у них появился оператор return, который может быть использован для выдачи некоторого финального значения, актуального на момент завершения итерации. Его можно использовать для проверки корректности выполнения генератора. Например, узнать, выполнился ли он без ошибок, что позволит коду, вызвавшему генератор, корректно обработать любую возникшую ситуацию.

Больше того, генераторы могут возвращать и выдавать выражения из других генераторов. Таким образом, можно разбивать сложные операции на более простые.

````php
function genA() {
    yield 2;
    yield 3;
    yield 4;
}

function genB() {
    yield 1;
    yield from genA(); // 'genA' вызывается и отрабатывает в этом месте
    yield 5;
    return 'success'; // финальный результат, который мы позже можем проверить
}

foreach (genB() as $val) {
    echo "\n $val"; // выдаст значения от 1 до 5
}

$genB()->getReturn(); // вернет 'success' при отсутствии ошибок
````

### Ожидания (expectations)
Ожидания (expectations) — улучшение функции assert() с сохранением обратной совместимости.

Они позволяют использовать утверждения с нулевой стоимостью (zero-cost assertions) в рабочем коде и поддерживают возможность генерации пользовательского исключения при возникновении ошибки при отработке утверждения, что может быть полезно при разработке.

Функция assert() стала языковой конструкцией в PHP 7. Утверждения должны быть использованы только во время разработки и тестирования с целью отладки. Для настройки её поведения мы должны использовать две директивы.

- zend.assertions
  1: генерируем и выполняем код (режим разработки) (значение по умолчанию)
  0: генерирует код, но обходит его во время выполнения
  -1: не генерирует код, делая его кодом с нулевой стоимостью (режим рабочего кода)

- assert.exception
  1: генерируется при ошибке утверждения путем создания соответствующего объекта исключения или же путем генерации объекта AssertionError, если такой объект не был создан
  0: использует или генерирует Throwable так, как было описано выше, но генерируется только предупреждение (warning) на базе того объекта, а не генерация исключения с его помощью (поведение, совместимое с PHP 5)

### Старые SAPI и расширения
Куда важнее тот факт, что были убраны старые и ненужные SAPI, такие как расширение mysql.
https://wiki.php.net/rfc/removal_of_dead_sapis_and_exts
https://wiki.php.net/rfc/remove_deprecated_functionality_in_php7

### Однообразный синтаксис описания переменных
Это обновление привнесло некоторые изменения в части согласованности для конструкций переменная-переменная. Оно позволит использовать более прогрессивные выражения с переменными, что, в отдельных случаях, приведет к изменению поведения кода, как показано ниже:

````php
                               // старый смысл           // новый смысл
$$foo['bar']['baz']     ${$foo['bar']['baz']}     ($$foo)['bar']['baz']
$foo->$bar['baz']       $foo->{$bar['baz']}       ($foo->$bar)['baz']
$foo->$bar['baz']()     $foo->{$bar['baz']}()     ($foo->$bar)['baz']()
Foo::$bar['baz']()      Foo::{$bar['baz']}()      (Foo::$bar)['baz']()
````

Это изменит поведение приложений, получающих доступ к переменным указанным способом. С другой стороны, вы сможете выделывать вот такие фокусы:

````php
// вложенный ()
foo()(); // Calls the return of foo()
$foo->bar()();

//IIFE (Immediately-invoked function expression или немедленно вызываемое выражение функции) синтаксис как в JavaScript
(function() {
    // тело функции
})();

// Вложенный ::
$foo::$bar::$baz
````

### Убраны тэги в старом стиле
Убраны или более некорректны открывающие/закрывающие тэги
````php
<% ... %>, <%= ... %>, <script language="php"> ... </script>
````

### Некорректные имена для классов, интерфейсов, трейтов
В результате добавлений, таких как типы возвращаемых значений и параметров, классы, интерфейсы и трейты больше не могут именоваться такими именами:

````php
bool
int
float
string
null
true
false
````


Подобное именование может привести к некорректной работе существующих приложений и библиотек, но легко поддаётся исправлению. Следующие имена тоже нежелательно использовать в выше названном качестве, поскольку они зарезервированы на будущее:

````php
resource
object
mixed
numeric
````


