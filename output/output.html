<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <title>PHP</title>
    <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
    <style type="text/css">
        @font-face {
            font-family: Arial;
            src: url(arial.ttf);
        }
        @font-face {
            font-family: Times;
            src: url(times.ttf);
        }
        @font-face {
            font-family: Sans;
            src: url(opensans.ttf);
        }
        * {
            background-color: #FFF;
            color:#000;
            font-family: Arial,serif;
        }
        pre {
            background:#F6F6F6;
            padding:16px;
            margin:4px;
            text-wrap: avoid;
            font-family: Times, "Times New Roman",cursive;
        }
        h1 {
            font-size:3rem;
        }
        h2 {
            font-size:2.5rem;
        }
        h1,h2 {
            text-align: center;
            font-weight:normal;
        }
        h3,h4,h5,h6 {
            font-weight:normal;
            font-size:2rem;
        }
        h1,h2,h3,h4,h5,h6 {
            font-family: Sans;
        }
    </style>
</head>
<body><p>Данный документ скомпилирован из различных источников (в основном с Хабра) и предназначен для подготовки к интервью на позицию веб-разработчика.</p>

<p>Так же в проекте есть скрипт writer.php , который собирает доки в один файл, чтобы его можно было бы распечатать.</p>

<p>Вопросы, предложения - велком
https://github.com/dminustin/php-developer-interview</p>


<h1>250 Вопросов Джуну / Мидлу / Сеньору</h1>

<p>Сурс: https://techrocks.ru/2021/04/18/250-php-job-interview-questions/</p>

<p>Сайт DOU.UA опубликовал статью со списком вопросов, которые задают PHP-разработчикам на технических собеседованиях. Разумеется, список не является исчерпывающим, но его формировали специалисты, выступающие в роли интервьюеров на собеседованиях.</p>

<p>Выкинул практические задания как ненужные, добавил ответы</p>

<h1>Junior</h1>

<h3>Что такое ссылки?</h3>

<p>Ссылки в PHP - это средство доступа к содержимому одной переменной под разными именами.</p>

<h3>Каковы основные операции с использованием ссылок?</h3>

<p>Есть три основных операции с использованием ссылок: присвоение по ссылке, передача по ссылке и возврат по ссылке.
ссылки PHP позволяют создать две переменные указывающие на одно и то же значение.</p>

<p>При присвоении, передаче или возврате неинициализированной переменной по ссылке, происходит её создание.</p>

<p>При присвоении, ссылки PHP позволяют создать переменные, указывающие на одно и то же значение.</p>

<pre>
$a = &$b;
$a и $b здесь абсолютно эквивалентны, но это не означает, что $a указывает на $b или наоборот. Это означает, что $a и $b указывают на одно и то же значение.
</pre>

<p>Вы можете передать переменную в функцию по ссылке, чтобы она могла изменять значение аргумента. Синтаксис выглядит следующим образом:</p>

<p>Возврат по ссылке используется в тех случаях, когда вы хотите использовать функцию для выбора переменной, с которой должна быть связана данная ссылка. Не используйте возврат по ссылке для увеличения производительности. Ядро PHP само занимается оптимизацией.</p>

<p>При сбросе ссылки, просто разрывается связь имени и содержимого переменной. Это не означает, что содержимое переменной будет уничтожено. Например:</p>

<p>unset($a); </p>

<h3>Назовите простые типы данных, поддерживаемые в РНР.</h3>

<pre>
bool (логический тип)
int (целые числа)
float (дробные числа)
string (строки)
array (массивы)
object (объекты)
callable (функции)
mixed (любой тип)
resource (ресурсы)
null (отсутствие значения)
</pre>

<p>Из этих типов данных первые четыре являются скалярными: bool, int, float, string</p>

<h3>Что такое инкремент и декремент, в чем разница между префиксным и постфиксным инкрементом и декрементом?</h3>

<p>Унарные операции увеличивают и уменьшают на единицу число, записанное в переменную.</p>

<p>При использовании префиксной нотации сначала происходит изменение переменной, а потом возврат. При использовании постфиксной нотации — наоборот: сначала возврат, а потом изменение переменной</p>

<h3>Что такое рекурсия?</h3>

<p>В общем смысле рекурсия это отображение чего-либо внутри самого себя. Рекурсивные алгоритмы используют рекурсивные функции, обладающие данным свойством.</p>

<p>Существует два варианта реализации рекурсивных функций: простой и сложный. В простом случае рекурсивная функция вызывает саму себя. В сложном — функция вызывает другую функцию, которая вызывает исходную функцию, с которой всё начиналось.</p>

<h3>В чем разница между =, == и ===?</h3>

<p>Присваивание, сравнение, строгое сравнение (сравниваются так же типы)</p>

<p>Существенная разница в том, что оператор сравнения двойное равенство сравнивает значения двух операндов. Напротив, оператор сравнения тройного равенства сравнивает значение и тип операндов.</p>

<h3>Какие знаете принципы ООП?</h3>

<ul>
<li>инкапсуляция
Инкапсуляция — объединение полей и методов в классе, с целью закрыть прямой доступ к полям и открыть его для методов, которые этими полями управляют.</li>
</ul>

<p>Согласно инкапсуляции, доступ к полям рекомендуется закрывать используя соответствующие спецификаторы доступа. Чтобы предоставить возможность вносить изменения или получать значения полей,  создаются специальные  методы.</p>

<ul>
<li>наследование</li>
</ul>

<p>позволяет создавать классы на основе уже существующих. Тем самым облегчая задачу по созданию новых классов с точки зрения использования уже существующего программного кода. Класс, от которого произошло наследование, называется базовым или родительским. Классы, которые произошли от базового, называются потомками, наследниками или производными классами. В PHP также используются абстрактные классы.</p>

<ul>
<li><p>абстракция
это класс, содержащий хотя бы один абстрактный метод. Он описан в программе, имеет поля, методы и не может использоваться для непосредственного создания объекта. То есть от абстрактного класса можно только наследовать. Объекты создаются только на основе производных классов, наследованных от абстрактного.</p></li>
<li><p>полиморфизм
в программировании означает возможность использования одного имени для методов  разных классов находящихся в одной иерархии наследования (т.е. в родственных классах) с целью выполнения схожих действий.</p></li>
</ul>

<p>Создание в производном классе метода с таким же именем что и имя метода родительского класса, называется переопределением метода.</p>

<p>Суть переопределения метода — производный класс в переопределяемом методе делает похожее, но отличающееся действие, чем действие метода родительского класса.</p>

<h3>Какая система типов используется в PHP? Опишите плюсы и минусы.</h3>

<p>Используется динамическая типизация, но можно включить строгую типизацию
declare(strict_types=1)</p>

<p>Плюсы: можно писать плохой код, который будет работать</p>

<p>Минусы: можно писать плохой код, который будет работать</p>

<h3>Чем отличаются ключевые слова: include и require</h3>

<p>функция include() выдает предупреждение, но скрипт продолжит выполнение, а функция require() выдает предупреждение и фатальную ошибку, т. е. скрипт не будет продолжать выполнение</p>

<h3>Что такое интерфейсы? Используете ли вы их? Если да — расскажите об этом.</h3>

<p>Интерфейс определяет абстрактный дизайн, которому должен соответствовать применяющий его класс. Интерфейс определяет методы без реализации. А класс затем применяет интерфейс и реализует эти методы. Применение интерфейса гарантирует, что класс имеет определенный функционал, описываемый интерфейсом.</p>

<p>Интерфейс определяется с помощью ключевого слова interface, за которым следует имя интерфейса и блок кода интерфейса в фигурных скобках:</p>

<h3>Что такое абстрактный класс и чем он отличается от интерфейса?</h3>

<p>Абстрактный класс используется для определения базового каркаса или проекта дочерних классов. Класс, который расширяет абстрактный класс, должен определять некоторые или все его абстрактные методы.</p>

<p>Экземпляры абстрактных классов не могут быть созданы напрямую.</p>

<p>Интерфейс / Абстрактный класс
Поддерживаем множественное наследование // Не поддерживаем множественное наследование
Абстрактный класс // Может содержать data members
Не содержит конструктор // Может содержать конструктор
Содержит только объявление методов (сигнатуры методов) // Может содержать как сигнатуры методов так и их реализации
Не может иметь модификаторов доступа - все методы по умолчанию публичные // Может иметь модификаторы доступа
Методы не могут быть статическими // Только методы, содержащие реализацию, могут быть объявлены статическими</p>

<h3>Может ли абстрактный класс содержать частный метод?</h3>

<p>Нет, если частный (private) метод объявлен абстрактным.</p>

<h3>Какие модификаторы видимости есть в РНР?</h3>

<p>public: к свойствам и методам, объявленным с данным модификатором, можно обращаться из внешнего кода и из любой части программы
protected: свойства и методы с данным модификатором доступны из текущего класса, а также из классов-наследников
private: свойства и методы с данным модификатором доступны только из текущего класса</p>

<h3>Какие магические методы вы знаете и как их применяют?</h3>

<p>Магические методы - это специальные методы, которые переопределяют действие PHP по умолчанию, когда над объектом выполняются определённые действия.</p>

<p>Следующие названия методов считаются магическими: __construct(), __destruct(), __call(), __callStatic(), __get(), __set(), __isset(), __unset(), __sleep(), __wakeup(), __serialize(), __unserialize(), __toString(), __invoke(), __set_state(), __clone() и __debugInfo()</p>

<p>Метод __set() будет выполнен при записи данных в недоступные (защищённые или приватные) или несуществующие свойства.</p>

<p>Метод __get() будет выполнен при чтении данных из недоступных (защищённых или приватных) или несуществующих свойств.</p>

<p>Метод __isset() будет выполнен при использовании isset() или empty() на недоступных (защищённых или приватных) или несуществующих свойствах.</p>

<p>Метод __unset() будет выполнен при вызове unset() на недоступном (защищённом или приватном) или несуществующем свойстве.</p>

<h3>Что такое генераторы и как их использовать?</h3>

<p>Генераторы предоставляют лёгкий способ реализации простых итераторов без использования дополнительных ресурсов или сложностей, связанных с реализацией класса, реализующего интерфейс Iterator.</p>

<p>Генератор позволяет вам писать код, использующий foreach для перебора набора данных без необходимости создания массива в памяти, что может привести к превышению лимита памяти, либо потребует довольно много времени для его создания. Вместо этого, вы можете написать функцию-генератор, которая, по сути, является обычной функцией, за исключением того, что вместо возврата единственного значения, генератор может возвращать (yield) столько раз, сколько необходимо для генерации значений, позволяющих перебрать исходный набор данных.</p>

<pre>
function xrange($start, $limit, $step = 1) {
    for ($i = $start; $i >= $limit; $i += $step) {
        yield $i;
    }
}
</pre>

<p>вызов range(0, 1000000) приведёт к использованию более 100 МБ
Обратите внимание, что и range() и xrange() дадут один и тот же вывод</p>

<pre>
echo 'Нечётные однозначные числа с помощью range():  ';
foreach (range(1, 9, 2) as $number) {
    echo "$number ";
}
echo "\n";

echo 'Нечётные однозначные числа с помощью xrange(): ';
foreach (xrange(1, 9, 2) as $number) {
    echo "$number ";
}
</pre>

<h3>Что делает оператор yield?</h3>

<p>В самом простом варианте оператор "yield" можно рассматривать как оператор "return", за исключением того, что вместо прекращения работы функции, "yield" только приостанавливает её выполнение и возвращает текущее значение, и при следующем вызове функции она возобновит выполнения с места, на котором прервалась.</p>

<h3>Что такое traits? Альтернативное решение? Приведите пример.</h3>

<p>Трейты — альтернативный механизм переиспользования общего кода в разных классах. Он устраняет ограничения, которыми обладает наследование и заменяет его.</p>

<p>Трейты похожи на абстрактные классы. Они реализуют какую-то общую функциональность и с ними нельзя работать напрямую. Единственный способ использовать их – включение в другие классы.</p>

<p>Трейты в отличие от наследования, не фиксируют структуру классов. Любой класс может включать в себя любое количество трейтов.</p>

<pre>
trait Magic
{
    // Доступно только внутри трейта
    private $properties;

    public function __get($key) {return $this->properties[$key] ?? null;}

    public function __set($key, $value) {$this->properties[$key] = $value;}
}
</pre>

<pre>
class Config
{
    // Включение трейта в класс
    use Magic;
}

$config = new Config();
$config->key = 'value';
echo $config->key;
</pre>

<h3>Опишите поведение при использовании traits с одинаковыми именами полей и / или методов.</h3>

<p>В случае если в классе будет объявлен метод, с таким же именем как в трейтах, то будет использоваться именно он и никаких ошибок не будет
В случае, если в классе НЕТ такого метода, а в трейтах есть методы с одинаковыми именами, будет Fatal Error. Устранить его можно указав какой метод надо использовать с помощью ключевого слова insteadof.</p>

<pre>
class Talker {
    use A, B {
        B::smallTalk insteadof A;
        A::bigTalk insteadof B;
    }
}
</pre>

<h3>Будут ли доступны частные методы trait в классе?</h3>

<p>в использующем трейт классе будут доступны как публичные, так и приватные методы и свойства класса.</p>

<h3>Можно ли компоновать traits в trait?</h3>

<p>Трейты, подобно классам, также могут использовать другие трейты.</p>

<h3>Расскажите об обработке ошибок и исключения (try catch, finaly и throw).</h3>

<p>Модель исключений (exceptions) в PHP похожа с используемыми в других языках программирования. Исключение можно сгенерировать (выбросить) при помощи оператора throw, и можно перехватить (поймать) оператором catch. Код генерирующий исключение, должен быть окружён блоком try, для того, чтобы можно было перехватить исключение. Каждый блок try должен иметь как минимум один соответствующий ему блок catch или finally.</p>

<p>В случае, если выброшено исключение, для которого нет блока catch в текущей функции, это исключение будет "всплывать" по стеку вызова, пока не будет найден подходящий блок catch. При этом, все встреченные блоки finally будут исполнены. Если стек вызовов раскрутится до глобальной области видимости, не встретив подходящего блока catch, программа завершит работу с фатальной ошибкой, если только у вас не настроен глобальный обработчик исключений.</p>

<h3>Что такое type hinting, как работает, зачем нужен?</h3>

<p>Type Hinting — это механизм, который позволяет явно указывать типы параметров. Интерпретатор использует их и применяет исключение в тех ситуациях, когда тип не соответствует ожидаемому.</p>

<h3>Что такое namespace-ы и зачем они нужны?</h3>

<p>Пространства имен позволяют избежать конфликта имен и сгруппировать функционал. Внутри пространства имен могут быть размещены классы, интерфейсы, функции и константы.</p>

<p>Если какая-та конструкция (например, класс или функция) определена вне любого пространства имен, то считается, что она расположена в глобальном пространстве имен.</p>

<p>Определение пространства имен
Для создания пространства имен применяется директива namespace, после которой идет название пространства имен</p>

<h3>Сравнение значений переменных в РНР и подводные камни? Приведение типов. Что изменилось в PHP 8 в этом контексте?</h3>

<p>В PHP8, сравнивает строку и число как числа только если строка представляет собой число. Иначе, число будет конвертировано в строку, и будет производится строковое сравнение.</p>

<h3>Как работает session в РНР, где хранится, как инициализируется?</h3>

<p>Сессия — это механизм для сохранения информации на разных веб-страницах для идентификации пользователей при навигации по сайту или приложению.
Использовать функцию session_start
Это метод, который вы встретите чаще всего, когда сессия запускается функцией session_start.</p>

<p>Если вам необходимо использовать сессии во всем приложении, вы также можете автоматически начинать их без использования функции session_start.</p>

<p>В файле php.ini есть опция конфигурации, которая позволяет автоматически запускать сессии для каждого запроса — session.auto_start. По умолчанию для нее установлено 0, но вы можете установить значение 1, чтобы включить функцию автоматического запуска.</p>

<p>Данные сессий хранятся на сервере. По умолчанию они записываются в файлы, но можно задать свой собственный механизм хранения данных сессий (например с использованием базы данных). Если хотите подробностей, смотрите функцию session_set_save_handler.</p>

<h3>Суперглобальные массивы. Какие знаете? Как использовали?</h3>

<p>Массивы, доступные отовсюды из приложения, например, $_SERVER, $_GET, $_POST и другие</p>

<h3>Сравните include vs required, include_once vs required_once.</h3>

<p>функция include() выдает предупреждение, но скрипт продолжит выполнение, а функция require() выдает предупреждение и фатальную ошибку, т. е. скрипт не будет продолжать выполнение
once говорит о том, что загрузить один и тот же файл нужно всего один раз.</p>

<h3>Что означает сложность алгоритма?</h3>

<p>Понятие «сложность алгоритма» (обозначается как Big O). Оно даёт понимание того, насколько эффективен алгоритм.
В информатике алгоритмы сравниваются друг с другом по их алгоритмической сложности. Эта сложность оценивается как количество выполняемых операций алгоритмом для достижения своей цели. Например разные способы сортировки требуют очень разного количества "проходов" по массиву перед тем как массив будет полностью отсортирован.</p>

<h3>Что такое замыкание в PHP? Приведите пример.</h3>

<p>Анонимные функции, также известные как замыкания (closures), позволяют создавать функции, не имеющие определённых имён. Они наиболее полезны в качестве значений callable-параметров, но также могут иметь и множество других применений.</p>

<p>Анонимные функции реализуются с использованием класса Closure.</p>

<h3>В чем разница между замыканием в PHP и JavaScript?</h3>

<p>В JavaScript замыкание можно рассматривать как область видимости: когда вы определяете функцию, она молча наследует область, в которой она определена, которая называется замыканием, и сохраняет ее независимо от того, где она используется. Несколько функций могут совместно использовать одно и то же замыкание, и они могут иметь доступ к нескольким замыканиям, если они находятся в доступной области.</p>

<p>В PHP замыкание — это вызываемый класс, к которому вы вручную привязываете свои параметры.</p>

<h3>Что такое позднее связывание? Расскажите о поведении и применения static.</h3>

<p>PHP реализует функцию, называемую позднее статическое связывание, которая может быть использована для того, чтобы получить ссылку на вызываемый класс в контексте статического наследования.</p>

<p>Слово «self», в строке return self::$model; указывает на текущий класс
Если слово «self» заменить на «static», то мы получим «позднее статическое связывание», т.е. связь будет установлена с тем классом, который вызывает данный код</p>

<h3>Как переопределить хранение сессий?</h3>

<p>Например, в настройках session.save_handler</p>

<h3>Расскажите о SPL-библиотеке (Reflection, autoload, структуры данных).</h3>

<p>spl_autoload_register — Регистрирует заданную функцию в качестве реализации метода __autoload()
Автолоадер используется для поиска и включения нужного файла, содержащего требуемый класс</p>

<h3>Расскажите о принципах SOLID.</h3>

<h4>Принцип единственной ответственности (Single responsibility)</h4>

<p>Принцип единственной ответственности гласит — «На каждый объект должна быть возложена одна единственная обязанность». Т.е. другими словами — конкретный класс должен решать конкретную задачу — ни больше, ни меньше.</p>

<h4>Принцип открытости/закрытости (Open-closed)</h4>

<p>Данный принцип гласит — "программные сущности должны быть открыты для расширения, но закрыты для модификации". На более простых словах это можно описать так — все классы, функции и т.д. должны проектироваться так, чтобы для изменения их поведения, нам не нужно было изменять их исходный код.</p>

<h4>Принцип подстановки Барбары Лисков (Liskov substitution)</h4>

<p>«Объекты в программе могут быть заменены их наследниками без изменения свойств программы».</p>

<p>При использовании наследника класса результат выполнения кода должен быть предсказуем и не изменять свойств метод</p>

<h4>Принцип разделения интерфейса (Interface segregation)</h4>

<p>Данный принцип гласит, что «Много специализированных интерфейсов лучше, чем один универсальный»</p>

<p>Соблюдение этого принципа необходимо для того, чтобы классы-клиенты использующий/реализующий интерфейс знали только о тех методах, которые они используют, что ведёт к уменьшению количества неиспользуемого кода.</p>

<h4>Принцип инверсии зависимостей (Dependency Invertion)</h4>

<p>«Зависимости внутри системы строятся на основе абстракций. Модули верхнего уровня не зависят от модулей нижнего уровня. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций». Данное определение можно сократить — «зависимости должны строится относительно абстракций, а не деталей».</p>

<h3>Расскажите о шаблонах GRASP.</h3>

<p>GRASP — General Responsibility Assignment Software Patterns (основные шаблоны распределения обязанностей в программном обеспечении)</p>

<p>GRASP состоит из 9 шаблонов:
- Creator
- Controller
- Pure Fabrication
- Information Expert
- High Cohesion
- Indirection
- Low Coupling
- Polymorphism
- Protected Variations</p>

<h4>Информационный эксперт (Information Expert)</h4>

<p>Ответственность должна быть назначена тому, кто владеет максимумом необходимой информации для исполнения — информационному эксперту.</p>

<p>В следующем примере на C# класс Customer содержит ссылки на все заказы клиентов, следовательно логично разместить тут метод для подсчета общей стоимости заказов</p>

<h4>Создатель (Creator)</h4>

<p>Creator или Создатель — суть ответственности такого объекта в том, что он создает другие объекты. Сразу напрашивается аналогия с абстрактной фабрикой.</p>

<p>По сути шаблон проектирования Абстрактная фабрика (создание объектов концентрируется в отдельном классе) это альтернатива создателя.</p>

<p>Но есть ряд моментов, которые должны выполняться, когда мы наделяем объект ответственностью создателя:</p>

<ul>
<li>Создатель содержит или агрегирует создаваемые объекты</li>
<li>Создатель использует создаваемые объекты</li>
<li>Создатель знает, как проинициализировать создаваемый объект</li>
<li>Создатель записывает создаваемые объекты</li>
<li>Создатель имеет данные инициализации</li>
</ul>

<h4>Controller</h4>

<p>Шаблон сontroller призван решить проблему разделения интерфейса и логики в интерактивном приложении. Это не что иное, как хорошо известный контроллер из MVC парадигмы. Контролер отвечает за обработку запросов и решает кому должен делегировать запросы на выполнение. Если обобщить назначение сontroller, то он должен отвечать за обработку входных системных сообщений.</p>

<h4>Слабая связанность (зацепление) или Low Coupling</h4>

<p>Если объекты в приложении сильно связанны, то любой их изменение приводит к изменениям во всех связанных объектах. А это неудобно и порождает множество проблем. Low coupling как раз говорит о том что необходимо, чтобы код был слабо связан и зависел только от абстракций. Слабая связанность так же встречается в SOLID принципах как The Dependency Inversion Principle​ (DIP) и слабая связанность по сути это реализация Dependency Injection принципа. Когда мы уходим от конкретных реализаций и абстрагируемся на уровнях интерфейсов(которые легко подменять нужными нам реализациями), тогда код не завязан на определенные реализации.</p>

<h4>Высокая связанность (High Cohesion)</h4>

<p>По сути High Cohesion очень тесно связанна с Single Responsibility Principle​ (SRP) с SOLID принципов. High Cohesion получается в результате соблюдения SRP.</p>

<p>High Cohesion принцип говорит о том, что класс должен стараться выполнять как можно меньше не специфичных для него задач, и иметь вполне определенную область применения. Только с опытом приходит понимание балансировки между High Cohesion и Low Coupling. считается что Low Coupling и High Cohesion) это инь и янь проектирования ПО. Некорректное юзание High Cohesion порождает неправильное Low Coupling и наоборот.</p>

<h4>Чистая выдумка (Pure Fabrication)</h4>

<p>Pure Fabrication или чистая выдумка, или чистое синтезирование. Здесь суть в выдуманном объекте. Аналогом может быть шаблон Service (сервис) в парадигме DDD.</p>

<p>Какую проблему решает Pure Fabrication?</p>

<ul>
<li>Уменьшает зацепление ( Low Coupling);</li>
<li>Повышает связанность (High Cohesion) ;</li>
<li>Упрощает повторное использование кода.</li>
</ul>

<p>К примеру у вас есть объект Customer и следую шаблону  информационный эксперт вы наделили его логикой которую мы показывали выше, как вы реализуете сохранение Customera в БД?</p>

<p>Так вот следуя Pure Fabrication принципу, мы создадим Сервис или репозиторий который будет доставать и сохранять такой объект в базу данных.</p>

<h4>Посредник (Indirection)</h4>

<p>Indirection или посредник. Можно столкнуться с таким вопросом: «Как определить ответственность объекта и избежать сильной связанности между объектами, даже если один класс нуждается в функционале (сервисах), который предоставляет другой класс?»</p>

<p>Решение: возложите ответственность на промежуточный объект, чтобы он осуществлял связь между другими компонентами или службами, чтобы они не были напрямую связаны. Такое решение можно сделать с помощью GoF паттерна медиатор</p>

<h4>Полиморфизм (Polymorphism)</h4>

<p>Полиморфизм позволяет реализовывать одноименные публичные методы, позволяя различным классам выполнять различные действия при одном и том же вызове. То есть объекты классов Square и Circle могут отображаться(реализовывать метод render) по разному несмотря не то, что они оба подклассы Shape, метод render определен в Shape. (Overriding).</p>

<p>Принцип полиморфизма является основополагающим в ООП. В этом контексте принцип тесно связан с GoF паттерном strategy. Это самый яркий пример реализации полиморфизма.</p>

<h4>Устойчивость к изменениям (Protected Variations)</h4>

<p>Проблема: Как спроектировать объекты, подсистемы и системы таким образом, чтобы изменения или нестабильность этих элементов не оказывали нежелательного влияния на другие элементы?</p>

<p>Решение: Определите точки прогнозируемого изменения или нестабильности, распределите обязанности по созданию стабильного интерфейса вокруг них.</p>

<p>По мнению многих это самый важный принцип который косвенно связан с остальными принципами GRASP. В настоящее время одним из наиболее важных показателей качества кода является простота изменений. Как архитекторы и программисты, мы должны быть готовы к постоянно меняющимся требованиям. Это не является «nice to have» атрибутом - это «must-have» в любом приложении и наша обязанность как программистов и архитекторов нашей системы это обеспечить.</p>

<h3>Расскажите о Dependency Injection: что такое DI-контейнеры? Какие есть варианты реализаций?</h3>

<p>Внедрение зависимости — процесс предоставления внешней зависимости программному компоненту. Является специфичной формой «инверсии управления» (Inversion of control, IoC), когда она применяется к управлению зависимостями. В полном соответствии с принципом единственной обязанности объект отдаёт заботу о построении требуемых ему зависимостей внешнему, специально предназначенному для этого общему механизму.</p>

<p>Приложение может предоставить эти зависимости при создании класса или передать их функциям, которым нужна каждая зависимость.</p>

<p>Требуемую зависимость можно передать как:
- аргумент в конструкторе
- установить через setter</p>

<h3>Что вам известно о MVC?</h3>

<p>Концепция MVC (Model-View-Controller: модель-вид-контроллер)</p>

<p>Контроллер управляет запросами пользователя (получаемые в виде запросов HTTP GET или POST, когда пользователь нажимает на элементы интерфейса для выполнения различных действий). Его основная функция — вызывать и координировать действие необходимых ресурсов и объектов, нужных для выполнения действий, задаваемых пользователем. Обычно контроллер вызывает соответствующую модель для задачи и выбирает подходящий вид.</p>

<p>Модель - это данные и правила, которые используются для работы с данными, которые представляют концепцию управления приложением. В любом приложении вся структура моделируется как данные, которые обрабатываются определённым образом. Что такое пользователь для приложения — сообщение или книга? Только данные, которые должны быть обработаны в соответствии с правилами (дата не может указывать в будущее, e-mail должен быть в определённом формате, имя не может быть длиннее Х символов, и так далее).</p>

<p>Вид обеспечивает различные способы представления данных, которые получены из модели. Он может быть шаблоном, который заполняется данными. Может быть несколько различных видов, и контроллер выбирает, какой подходит наилучшим образом для текущей ситуации.</p>

<p>Веб приложение обычно состоит из набора контроллеров, моделей и видов. Контроллер может быть устроен как основной, который получает все запросы и вызывает другие контроллеры для выполнения действий в зависимости от ситуации.</p>

<h3>Что вам известно о шаблонах GoF?</h3>

<p>Шаблоны проектирования "банды четырёх (GoF)"</p>

<p>Паттернами проектирования (Design Patterns) называют решения часто встречающихся проблем в области разработки программного обеспечения. В данном случае предполагается, что есть некоторый набор общих формализованных проблем, которые довольно часто встречаются, и паттерны предоставляют ряд принципов для решения этих проблем.</p>

<p>Концепцию паттернов впервые описал Кристофер Александер в книге «Язык шаблонов. Города. Здания. Строительство».</p>

<p>Идея показалась привлекательной авторам Эриху Гамму, Ричарду Хелму, Ральфу Джонсону и Джону Влиссидесу, их принято называть «бандой четырёх» (Gang of Four). В 1995 году они написали книгу «Design Patterns: Elements of Reusable Object-Oriented Software», в которой применили концепцию типовых паттернов в программировании. В книгу вошли 23 паттерна, решающие различные проблемы объектно-ориентированного дизайна.</p>

<h4>Порождающие паттерны:</h4>

<p>Порождающие паттерны — это паттерны, которые абстрагируют процесс инстанцирования или, иными словами, процесс порождения классов и объектов. Среди них выделяются следующие:</p>

<ul>
<li>Абстрактная фабрика (Abstract Factory)</li>
<li>Строитель (Builder)</li>
<li>Фабричный метод (Factory Method)</li>
<li>Прототип (Prototype)</li>
<li>Одиночка (Singleton)</li>
</ul>

<h4>Структурные паттерны:</h4>

<p>Структурные паттерны - рассматривает, как классы и объекты образуют более крупные структуры - более сложные по характеру классы и объекты. К таким шаблонам относятся:</p>

<ul>
<li>Адаптер (Adapter)</li>
<li>Мост (Bridge)</li>
<li>Компоновщик (Composite)</li>
<li>Декоратор (Decorator)</li>
<li>Фасад (Facade)</li>
<li>Приспособленец (Flyweight)</li>
<li>Заместитель (Proxy)</li>
</ul>

<h4>Поведенческие паттерны:</h4>

<p>Поведенческие паттерны - они определяют алгоритмы и взаимодействие между классами и объектами, то есть их поведение. Среди подобных шаблонов можно выделить следующие:</p>

<ul>
<li>Цепочка обязанностей (Chain of responsibility)</li>
<li>Команда (Command)</li>
<li>Интерпретатор (Interpreter)</li>
<li>Итератор (Iterator)</li>
<li>Посредник (Mediator)</li>
<li>Хранитель (Memento)</li>
<li>Наблюдатель (Observer)</li>
<li>Состояние (State)</li>
<li>Стратегия (Strategy)</li>
<li>Шаблонный метод (Template method)</li>
<li>Посетитель (Visitor)</li>
</ul>

<h3>Что вам известно о шаблонах, которые применяются в ORM?</h3>

<p>ORM (Object-Relation Mapping) – общее название для фреймворков, позволяющих автоматически связать базу данных с кодом. Они стараются скрыть существование базы данных настолько, насколько это возможно. Взамен, программисту дают возможность оперировать данными в базе через специальный интерфейс. Вместо построения SQL-запросов, программист вызывает простые методы, а всю остальную работу берёт на себя ORM.</p>

<h3>Напишите на PHP пример реализации паттерна Singleton.</h3>

<pre>
class Singleton {
  protected static $object = null;
  protected function __countruct()
  {
    //do something
  }
  public static function getInstance(): static
  {
    return (static::$object) ? static::$object : (static::$object = new static())     
  }
}
</pre>

<h3>Что такое Docker? Каков принцип его работы?</h3>

<p>Docker — это платформа контейнеризации с открытым исходным кодом, с помощью которой можно автоматизировать создание приложений, их доставку и управление. Платформа позволяет быстрее тестировать и выкладывать приложения, запускать на одной машине требуемое количество контейнеров.</p>

<h3>Что такое LAMP / NAMP?</h3>

<p>LAMP — это стек программного обеспечения, устанавливаемого на сервер и предназначенного для сайтов и веб-приложений. LAMP – это аббревиатура, она расшифровывается как: Linux, Apache, MySQL и PHP</p>

<h3>Расскажите о regexp.</h3>

<p>Регуля́рные выраже́ния — формальный язык, используемый в компьютерных программах, работающих с текстом, для поиска и осуществления манипуляций с подстроками в тексте, основанный на использовании метасимволов. Для поиска используется строка-образец, состоящая из символов и метасимволов и задающая правило поиска.</p>

<h3>Расскажите о SSH-протоколе.</h3>

<p>SSH (англ. Secure Shell — «безопасная оболочка») — сетевой протокол прикладного уровня, позволяющий производить удалённое управление операционной системой и туннелирование TCP-соединений (например, для передачи файлов).</p>

<h3>Что такое PDO?</h3>

<p>PHP Data Objects — расширение для PHP, предоставляющее разработчику универсальный интерфейс для доступа к различным базам данных. PDO предлагает единые методы для работы с различными базами данных, хотя текст запросов может немного отличаться.</p>

<h3>Что такое PHP PEAR?</h3>

<p>PEAR — это библиотека классов PHP с открытым исходным кодом, распространяемых через одноименный пакетный менеджер. В стандартную поставку PHP входит система управления классами PEAR, которая позволяет легко скачивать и обновлять их.</p>

<h3>Какие версии PHP до сих пор поддерживаются?</h3>

<p>7.4 и выше</p>

<h3>В чем разница между GET и POST?</h3>

<p>Основное отличие метода GET от POST в способе передачи данных. Запрос GET передает данные в URL в виде пар "имя-значение" (другими словами, через ссылку), а запрос POST передает данные в теле запроса</p>

<p>GET запросы могут кешироваться сервером </p>

<h3>Чем отличаются операторы BREAK и CONTINUE?</h3>

<p>BREAK останавливает цикл и передает управление коду за циклом
CONTINUE пропускает итерацию и продолжает цикл</p>

<h3>Есть ли разница между одинарными и двойными кавычками?</h3>

<p>В PHP текст одинарной кавычки рассматривается как строковое значение, а текст двойной кавычки будет анализировать переменные, заменяя и обрабатывая их значение.</p>

<h3>Что такое Cookie и зачем они используются?</h3>

<p>Cookies - это механизм хранения данных браузером удалённой машины для отслеживания или идентификации возвращающихся посетителей.</p>

<h3>Что нельзя хранить в Cookie и почему?</h3>

<p>Любые данные, которые хранятся в cookie, посетитель может изменить. Соответственно, хранить в cookie можно только ID сессии,
какие-то ключи пользователя, настройки пользователя, и статистические данные.</p>

<h2>Git</h2>

<h3>Какой командой добавить изменения?</h3>

<p>git add</p>

<h3>Какой командой зафиксировать изменения?</h3>

<p>git commit</p>

<h3>Какой командой отправить изменения в удаленный репозиторий?</h3>

<p>git push</p>

<h2>Базы данных</h2>

<h3>Что такое транзакция?</h3>

<p>Транзакция — это набор операций по работе с базой данных (БД), объединенных в одну атомарную пачку.
Атомарность предполагает что либо все операции выполнятся, либо не выполнится ни одна из них (откат, rollback)</p>

<h3>Что такое нормализация?</h3>

<p>Нормализация – это метод проектирования базы данных, который позволяет привести базу данных к минимальной избыточности</p>

<p>Избыточность данных – это когда одни и те же данные хранятся в базе в нескольких местах, так как в этом случае необходимо добавлять, изменять или удалять одни и те же данные в нескольких местах.</p>

<h3>Что такое денормализация? Для чего она нужна?</h3>

<p>Денормализация — намеренное приведение структуры базы данных в состояние, не удовлетворяющее требованиям нормализации.</p>

<p>Денормализация обычно проводится путем добавления избыточных данных в таблицу, т.е. тех данных, которые по требованиям той или иной нормальной формы должны выноситься в отдельную таблицу.</p>

<p>Нужна для повышения производительности.</p>

<h3>Какие есть типы связей в базе данных?</h3>

<ul>
<li>Многие ко многим.</li>
<li>Один ко многим.</li>
<li>Один к одному.</li>
</ul>

<h3>Что означает утверждение о том, что СУБД поддерживает контроль ссылочной целостности связей?</h3>

<p>Ссылочная целостность – это ограничение базы данных, гарантирующее, что ссылки между данными являются действительно правомерными и неповрежденными. Ссылочная целостность является фундаментальным принципом теории баз данных и проистекает из той идеи, что база данных должна не только сохранять данные, но и активно содействовать обеспечению их качества.</p>

<p>Ссылочная целостность – это предохранительное устройство системы управления базами данных, гарантирующее, что каждый внешний ключ соответствует первичному ключу. 
Например, номера заказчиков являются первичными ключами в файле заказчиков и внешними ключами в файле заказов. 
При удалении записи заказчика должны быть удалены соответствующие записи заказов; в противном случае они останутся без исходной связи. Если СУБД не проверяет этого, соответствующий механизм должен программироваться в приложении.</p>

<h3>Если используемая вами СУБД не поддерживает каскадные удаления для поддержки ссылочной целостности связей, что можно сделать для достижения аналогичного результата?</h3>

<p>Реализовать этот механизм в приложении</p>

<h3>Что такое первичный и внешний ключи?</h3>

<p>Внешний ключ — это столбец или комбинация столбцов, значения которых соответствуют Первичному ключу в другой таблице. Связь между двумя таблицами задается через соответствие Первичного ключа в одной из таблиц внешнему ключу во второй.</p>

<h3>В чем разница между первичным и уникальным ключами?</h3>

<ul>
<li>В таблице может быть один первичный ключ, а в таблице может быть несколько уникальных ключей.</li>
<li>Цель первичного ключа состоит в том, чтобы обеспечить целостность объекта, с другой стороны, цель уникального ключа – обеспечить уникальные данные.</li>
<li>В первичном ключе индекс по умолчанию кластеризован, тогда как в уникальном ключе индекс по умолчанию не кластеризован</li>
<li>Первичный ключ не допускает пустые столбцы, а уникальный – пустые.</li>
<li>В первичном ключе дублирующиеся ключи не допускаются, тогда как в уникальном ключе, если одна или несколько частей ключа являются нулевыми, то дубликаты ключей допускаются.</li>
</ul>

<h3>Какие есть типы JOIN и чем они отличаются?</h3>

<h4>INNER JOIN</h4>

<p>Этот вид джойна выведет только те строки, если условие соединения выполняется (является истинным, т.е. TRUE). В запросах необязательно прописывать INNER – если написать только JOIN, то СУБД по умолчанию выполнить именно внутреннее соединение.</p>

<h4>LEFT JOIN и RIGHT JOIN</h4>

<p>Левое и правое соединения еще называют внешними. Главное их отличие от внутреннего соединения в том, что строка из левой (для LEFT JOIN) или из правой таблицы (для RIGHT JOIN) попадет в результаты в любом случае. Давайте до конца определимся с тем, какая таблица левая, а какая правая.
Левая таблица та, которая идет перед написанием ключевых слов LEFT | RIGHT| INNER JOIN, правая таблица – после них</p>

<h4>FULL JOIN</h4>

<p>Полное внешнее соединение.
Этот вид джойна вернет все строки из всех таблиц, участвующих в соединении, соединив между собой те, которые подошли под условие ON.</p>

<h3>Что такое курсоры в базах данных?</h3>

<p>Курсор — ссылка на контекстную область памяти. В некоторых реализациях языка программирования SQL (Oracle, Microsoft SQL Server) — получаемый при выполнении запроса результирующий набор и связанный с ним указатель текущей записи. бы сказал, что курсор — это виртуальная таблица которая представляет собой альтернативное хранилище данных. При этом курсор, позволяет обращаться к своим данным, как к данным обычного массива.</p>

<h3>Что такое агрегатные функции SQL? Приведите несколько примеров.</h3>

<p>В управлении базами данных функция агрегирования или функция агрегирования — это функция, в которой значения нескольких строк группируются вместе для формирования единого суммарного значения.</p>

<p>В MySQL есть следующие агрегатные функции:</p>

<ul>
<li>AVG: вычисляет среднее значение</li>
<li>SUM: вычисляет сумму значений</li>
<li>MIN: вычисляет наименьшее значение</li>
<li>MAX: вычисляет наибольшее значение</li>
<li>COUNT: вычисляет количество строк в запросе</li>
</ul>

<h3>Что такое миграции?</h3>

<p>Миграция - это именованный набор SQL-скриптов. Механизм миграций основан на последовательном применении SQL-скриптов для обновления структуры базы данных с помощью консольного приложения-мигратора.</p>

<h3>Расскажите о связи один к одному, один ко многим, многие ко многим.</h3>

<p>Связь один к одному образуется, когда ключевой столбец (идентификатор) присутствует в другой таблице, в которой тоже является ключом либо свойствами столбца задана его уникальность (одно и тоже значение не может повторяться в разных строках).</p>

<p>В типе связей один ко многим одной записи первой таблицы соответствует несколько записей в другой таблице.</p>

<p>Если нескольким записям из одной таблицы соответствует несколько записей из другой таблицы, то такая связь называется «многие ко многим» и организовывается посредством связывающей таблицы.</p>

<h3>Назовите и объясните три любых агрегирующих метода.</h3>

<ul>
<li>AVG: вычисляет среднее значение</li>
<li>SUM: вычисляет сумму значений</li>
<li>MIN: вычисляет наименьшее значение</li>
<li>MAX: вычисляет наибольшее значение</li>
<li>COUNT: вычисляет количество строк в запросе</li>
</ul>

<h3>Зачем используют оператор группировки GROUP BY?</h3>

<p>Оператор SQL GROUP BY служит для распределения строк - результата запроса - по группам, в которых значения некоторого столбца, по которому происходит группировка, являются одинаковыми. Группировку можно производить как по одному столбцу, так и по нескольким.</p>

<p>Часто оператор SQL GROUP BY применяется вместе с агрегатными функциями (COUNT, SUM, AVG, MAX, MIN). В этих случаях агрегатные функции служат для вычисления соответствующего агрегатного значения ко всему набору строк, для которых некоторый столбец - общий.</p>

<p>Если в результате запроса требуется вывести один столбец и по этому же столбцу производится группировка, то оператор GROUP BY просто выбирает уникальные значения и убирает дубликаты, то есть выполняет те же задачи, что и ключевое слово DISTINCT.</p>

<h3>В чем разница между WHERE и HAVING? Приведите примеры.</h3>

<p>Главное отличие HAVING от WHERE в том, что в HAVING можно наложить условия на результаты группировки, потому что порядок исполнения запроса устроен таким образом, что на этапе, когда выполняется WHERE, ещё нет групп, а HAVING выполняется уже после формирования групп</p>

<h3>В чем разница между операторами DISTINCT и GROUP BY?</h3>

<p>DISTINCT - получить уникальные строки (отличающиеся друг от друга любым отображаемым полем). Работает чуть быстрее.</p>

<p>GROUP BY - сгруппировать по какому-либо признаку, при этом можно использовать агрегатные функции SUM, AVG, MAX и т.д.</p>

<h3>Для чего нужны операторы UNION, INTERSECT, EXCEPT?</h3>

<p>Оператор UNION используется для объединения результирующего набора из двух или более операторов SELECT. Каждый оператор SELECT в UNION должен иметь одинаковое количество столбцов. Столбцы также должны иметь похожие типы данных и в каждой инструкции SELECT быть в том же порядке.</p>

<p>Оператор SQL INTERSECT реализует операцию реляционной алгебры пересечение множеств, оператор SQL EXCEPT - разность множеств. В виде множеств выступают результаты единичных запросов.</p>

<h3>Опишите разницу типов данных DATETIME и TIMESTAMP.</h3>

<p>DATETIME
Хранит время в виде целого числа вида YYYYMMDDHHMMSS, используя для этого 8 байтов. Это время не зависит от временной зоны. Оно всегда отображается при выборке точно так же, как было сохранено, независимо от того какой часовой пояс установлен в MySQL</p>

<p>TIMESTAMP
Хранит 4-байтное целое число, равное количеству секунд, прошедших с полуночи 1 января 1970 года по усреднённому времени Гринвича (т.е. нулевой часовой пояс, точка отсчёта часовых поясов). При получении из базы отображается с учётом часового пояса. Часовой пояс может быть задан в операционной системе, глобальных настройках MySQL или в конкретной сессии. Запомните, что сохраняется всегда количество секунд по UTC (универсальное координированное время, солнечное время на меридиане Гринвича), а не по локальному часовому поясу.</p>

<h3>Какие вы знаете движки таблиц и чем они отличаются?</h3>

<h4>InnoDB</h4>

<p>В MySQL 8 подсистема хранения данных InnoDB используется по умолчанию и является наиболее широко применяемой из всех других доступных подсистем хранения. Подсистема InnoDB была выпущена вместе с MySQL 5.1 как плагин в 2008 году, и она рассматривается как подсистема хранения по умолчанию, начиная с версии 5.5 и выше. Поддержка подсистемы хранения InnoDB была перенята корпорацией Oracle в октябре 2005 года у финской компании Innobase Oy.</p>

<p>Таблицы InnoDB поддерживают ACID-совместимые фиксации транзакций, откат и возможности аварийного восстановления для защиты пользовательских данных. InnoDB также поддерживает блокировку на уровне строк, что помогает улучшить параллелизм и производительность. InnoDB хранит данные в кластеризованных индексах, чтобы уменьшить операции ввода-вывода для всех запросов SQL на выборку данных на основе первичного ключа. InnoDB также поддерживает ограничения внешнего ключа, которые обеспечивают лучшую целостность данных в базе данных. Максимальный размер таблицы InnoDB может масштабироваться до 256 Тб, что должно быть вполне достаточным во многих случаях использования больших данных.</p>

<h4>MyISAM</h4>

<p>Подсистема хранения данных MyISAM использовалась по умолчанию для MySQL вплоть до версии 5.5 1. В отличие от InnoDB, таблицы подсистемы хранения данных MylSAM не поддерживают ACID-совместитмость. Таблицы MylSAM поддерживают только блокировку уровня таблицы, поэтому таблицы MyISAM небезопасны для транзакций. Таблицы MyISAM оптимизированы для сжатия и скорости. MyISAM обычно используется, когда вам нужно иметь в основном операции чтения с минимальными транзакционными данными. Максимальный размер таблицы MyISAM может достигать 256 Тб, что помогает в таких случаях, как анализ данных.</p>

<p>Подсистема хранения данных MyISAM поддерживает полнотекстовое индексирование, которое может помочь в сложных операциях поиска. С помощью полнотекстовых индексов можно индексировать данные, хранящиеся в типах данных BLOB и TEXT.</p>

<p>Из-за низких накладных расходов MyISAM использует более простую структуру, которая обеспечивает хорошую производительность; однако это не сильно помогает для получения хорошей производительности, когда есть потребность в лучшем параллелизме и случаях использования, которые не нуждаются в тяжелых операциях чтения. Наиболее распространенной проблемой производительности MyISAM является блокировка таблицы, которая может задерживать ваши параллельные запросы в очереди. Это происходит, когда она блокирует таблицу для любой другой операции до тех пор, пока более ранняя операция не будет выполнена.</p>

<p>Таблица MyISAM не поддерживает транзакции и внешние ключи. Судя по всему, из-за этих ограничений вместо таблиц MyISAM теперь системные таблицы схемы MySQL 8 используют таблицы InnoDB.</p>

<h4>Memory</h4>

<p>Подсистема хранения в памяти (подсистема оперативного хранения данных) обычно называется подсистемой хранения данных на основе кучи. Она используется для чрезвычайно быстрого доступа к данным. Эта подсистема хранения содержит данные в оперативной памяти, поэтому ей не нужны операции ввода- вывода. Поскольку она хранит данные в оперативной памяти, все данные теряются при перезапуске сервера. Такая подсистема в основном используется для временных таблиц или таблицы подстановки. Эта подсистема поддерживает блокировку на уровне таблицы, которая ограничивает параллелизм с высокой частотой записи.</p>

<p>Оперативная таблица хранит данные в оперативной памяти, которая имеет очень ограниченный объем; если вы попытаетесь записать слишком много данных в оперативную таблицу, она начнет свопить данные на диск, и тогда вы потеряете преимущества подсистемы хранения данных в памяти.
Оперативные таблицы не поддерживают типы данных TEXT и BLOB; такие типы данных могут не потребоваться, так как таблицы имеют ограниченную емкость.
Эта подсистема хранения может использоваться для кеширования результатов; таблицы поиска, например, или почтовые индексы и названия штатов.
Оперативные таблицы поддерживают индексы на основе B-дерева и хеш-индексы.</p>

<h4>Archive</h4>

<p>Эта подсистема хранения данных используется для хранения больших объемов исторических данных без каких-либо индексов. Архивные таблицы не имеют ограничений по объему хранимых данных. Архивная подсистема хранения данных оптимизирована для операций с высокой частотой вставки, а также поддерживает блокировку на уровне строк. Такие таблицы хранят данные в сжатом и малом форматах. Архивная подсистема не поддерживает операции DELETE или UPDATE; она разрешает только операции INSERT, REPLACE и SELECT.</p>

<h4>Blackhole</h4>

<p>Эта подсистема хранения данных принимает данные, но их не сохраняет. Вместо сохранения данных она отбрасывает (уничтожает) их после каждой вставки.</p>

<p>Эта подсистема хранения полезна для репликации с большим количеством серверов. Подсистема хранения данных Blackhole работает в качестве фильтрующего сервера между ведущим и ведомым серверами, который не хранит никаких данных, но который применяет только правила replicate-do-* и replicate-ignore-* и пишет двоичные журналы. Эти двоичные журналы используются для выполнения репликации на ведомых серверах.</p>

<h4>CSV</h4>

<p>Подсистема хранения данных CSV хранит данные в файлах в формате .csv, используя формат с разделением значений запятыми. Эта подсистема извлекает данные из базы данных и копирует их в .csv. Если вы создаете CSV-файл из электронной таблицы и копируете его на сервер папок данных MYSQL, она может читать данные с помощью запроса SELECT на выборку данных. Аналогичным образом, если вы записываете данные в таблицу, внешняя программа может их прочитать из CSV-файла. Эта подсистема хранения данных используется для обмена данными между программным обеспечением или приложениями. Таблица CSV не поддерживает индексирование и разделение. Чтобы избежать ошибок при создании таблицы, все столбцы в подсистеме хранения данных CSV должны быть определены с атрибутом NOT NULL.</p>

<h4>Merge</h4>

<p>Эта подсистема хранения данных также называется подсистемой хранения MRG_Myisam. Эта подсистема хранения объединяет все данные в одну таблицу MyISAM и использует ее для ссылки на единственное представление. В таблицах объединения/слияния все столбцы перечисляются в том же порядке. Эти таблицы хороши для сред объединения баз данных.</p>

<p>Как правило, эта подсистема используется для управления таблицами, связанными с журналом регистрации событий. В отдельных таблицах MyISAM можно задавать различные месяцы журналов и объединять эти таблицы с помощью подсистемы хранения данных MERGE.</p>

<p>Таблицы MyISAM имеют ограничение по объему хранения для операционной системы, но коллекция таблиц MyISAM (MERGE) не имеет таких ограничений. Таким образом, использование подсистемы MERGE позволит вам разделять данные на многочисленные таблицы MyISAM, что может помочь в преодолении ограничений по объему хранения.</p>

<p>С помощью подсистемы MERGE трудно выполнять разделение, следовательно, таблицами MERGE оно не поддерживается, и мы не можем реализовать раздел на таблице MERGE или любой таблице MyISAM.</p>

<h4>Federated</h4>

<p>Подсистема интегрированного хранения данных FEDERATED позволяет создавать одну базу данных на нескольких физических серверах. Она открывает клиентское соединение с другим сервером и выполняет запросы к таблице, получая и отправляя строки по мере необходимости. Первоначально она рекламировалась как конкурентная функциональность, которая поддерживала многие корпоративные проприетарные серверы баз данных, такие как Microsoft SQL Server и Oracle, но это всегда было натяжкой, мягко говоря. Хотя казалось, что в ней задействовалось много гибкости и хитрых приемов, она оказалась источником многих проблем и по умолчанию деактивирована. Однако мы можем ее активировать, запустив двоичный файл сервера MySQL с параметром --federated.</p>

<h4>NDB Cluster</h4>

<p>NDB Cluster (или просто NDB) - это подсистема хранения прямо в оперативной памяти, обеспечивающая высокую доступность и сохраняемость данных.</p>

<p>Кластерная подсистема хранения данных NDB Cluster может конфигурироваться с помощью ряда параметров аварийного переключения и балансировки нагрузки, но проще всего начать с подсистемы хранения на уровне кластера. NDB Cluster использует подсистему хранения NDB и содержит полный набор данных, который зависит только от других наборов данных, доступных в кластере.</p>

<p>Кластерная часть NDB Cluster настроена независимо от серверов MySQL. В NDB Cluster каждая часть кластера считается узлом.</p>

<p>Кластерный движок - данные автоматически разделяются и реплицируются по различным машинам, именуемым - дата узлы. Применяется для приложений, которые требуют высокой производительности с наивысшей степенью доступности. NDB хорошо работает на системах требующих высокой отдачи на операциях чтения. Для "тяжелых" приложений требующих активной записи в конкурирующей среде рассмотрите вариант с InnoDB.</p>

<h3>Какие способы оптимизации производительности баз данных знаете?</h3>

<h4>Оптимизация запросов</h4>

<p>В большинстве случаев проблемы с производительностью вызваны низкой производительностью SQL-запросов. При попытке оптимизировать эти запросы вы столкнетесь со многими дилеммами, например, использовать ли IN или EXISTS, писать ли подзапрос или объединение. Хотя вы можете платить хорошие деньги за консультационные услуги, вы также можете ускорить запросы SQL с помощью оптимизаторов запросов, которые ускорят запрос и объяснят рекомендации, чтобы вы могли учиться на будущее.</p>

<h4>Создать оптимальные индексы</h4>

<p>При правильной индексации можно оптимизировать продолжительность выполнения запроса и повысить общую производительность базы данных. Индексы достигают этого, внедряя структуру данных, которая помогает поддерживать порядок и облегчает поиск информации; в основном, индексирование ускоряет процесс поиска данных и делает его более эффективным, тем самым экономя ваше время (и вашу систему) и усилия.</p>

<h4>Более мощный процессор</h4>

<p>Чем лучше ваш процессор, тем быстрее и эффективнее будет ваша база данных. Поэтому, если ваша база данных работает не так, вы должны рассмотреть возможность обновления процессорного модуля более высокого класса; чем мощнее ваш процессор, тем меньше нагрузка при работе с несколькими приложениями и запросами. Кроме того, при оценке производительности ЦП важно отслеживать все аспекты производительности ЦП, в том числе время готовности ЦП (которое может рассказать вам о случаях, когда ваша система пыталась использовать ЦП, но не смогла, поскольку все ресурсы ЦП были слишком заняты или иным образом заняты).</p>

<h4>Больше памяти</h4>

<p>Подобно тому, как недостаточно мощный процессор может повлиять на эффективность базы данных, так же как и нехватка памяти. В конце концов, когда в базе данных недостаточно памяти для выполнения запрашиваемой работы, производительность базы данных по понятным причинам пойдет на спад. По сути, наличие большего объема памяти поможет повысить эффективность системы и общую производительность. Хороший способ проверить, нужно ли вам больше памяти, – посмотреть, сколько ошибок в вашей системе имеет страница; Если количество сбоев велико (например, в тысячах), это означает, что вашим хостам не хватает (или, возможно, полностью не хватает) доступного пространства памяти. Следовательно,</p>

<p>Кроме того, вы можете рассмотреть вопрос об увеличении объема памяти, используемой MySQL. Мы рекомендуем разрешить ему выделять 70% общей памяти (при условии, что база данных является единственным приложением на этом сервере). Вы можете изменить объем памяти, выделенной для базы данных, используя ключ innodb_buffer_pool_size в файле конфигурации MySQL, my.cnf.</p>

<h4>Дефрагментация данных</h4>

<p>Если у вас проблемы с медленной базой данных, другим возможным решением является дефрагментация данных. Когда в базу данных записывается много записей и время идет, записи фрагментируются во внутренних файлах данных MySQL и на самом диске. Дефрагментация диска позволит сгруппировать соответствующие данные, поэтому операции, связанные с вводом/выводом, будут выполняться быстрее, что напрямую повлияет на общую производительность запросов и базы данных. Кроме того, на некотором связанном примечании также важно иметь достаточно дискового пространства вообще, работая с базой данных; если вы действительно хотите оптимизировать производительность базы данных, обязательно используйте дефрагментацию диска, сохраняя при этом достаточно свободного дискового пространства для вашей базы данных.</p>

<h4>Типы дисков</h4>

<p>Для извлечения результатов даже одного запроса могут потребоваться миллионы операций ввода-вывода с диска, в зависимости от объема данных, к которым запрос должен получить доступ для обработки, и в зависимости от объема данных, возвращаемых из запроса. Таким образом, тип дисков на вашем сервере может сильно повлиять на производительность ваших SQL запросов. Работа с SSD-дисками может значительно повысить общую производительность базы данных и, в частности, производительность SQL-запросов.</p>

<h4>Версия базы данных</h4>

<p>Другим важным фактором производительности базы данных является версия MySQL, которую вы в настоящее время развертываете. Обновление последней версии базы данных может существенно повлиять на общую производительность базы данных. Возможно, что один запрос может работать лучше в старых версиях MySQL, чем в новых, но если посмотреть на общую производительность, новые версии, как правило, работают лучше.</p>

<h3>Что такое партиционирование, репликация и шардинг?</h3>

<h4>Партиционирование (partitioning)</h4>

<p>Партиционирование — это разбиение таблиц, содержащих большое количество записей, на логические части по неким выбранным администратором критериям. Партиционирование таблиц делит весь объем операций по обработке данных на несколько независимых и параллельно выполняющихся потоков, что существенно ускоряет работу СУБД. Для правильного конфигурирования параметров партиционирования необходимо, чтобы в каждом потоке было примерно одинаковое количество записей.</p>

<p>Например, на новостных сайтах имеет смысл партиционировать записи по дате публикации, так как свежие новости на несколько порядков более востребованы и чаще требуется работа именно с ними, а не со всех архивом за годы существования новостного ресурса.</p>

<h4>Репликация (replication)</h4>

<p>Репликация — это синхронное или асинхронное копирование данных между несколькими серверами. Ведущие сервера называют мастерами (master), а ведомые сервера — слэйвами (slave). Мастера используются для изменения данных, а слэйвы — для считывания. В классической схеме репликации обычно один мастер и несколько слэйвов, так как в большей части веб-проектов операций чтения на несколько порядков больше, чем операций записи. Однако в более сложной схеме репликации может быть и несколько мастеров.</p>

<p>Например, создание нескольких дополнительных slave-серверов позволяет снять с основного сервера нагрузку и повысить общую производительность системы, а также можно организовать слэйвы под конкретные ресурсоёмкие задачи и таким образом, например, упростить составление серьёзных аналитических отчётов — используемый для этих целей slave может быть нагружен на 100%, но на работу других пользователей приложения это не повлияет.</p>

<h4>Шардинг (sharding)</h4>

<p>Шардинг — это прием, который позволяет распределять данные между разными физическими серверами. Процесс шардинга предполагает разнесения данных между отдельными шардами на основе некого ключа шардинга. Связанные одинаковым значением ключа шардинга сущности группируются в набор данных по заданному ключу, а этот набор хранится в пределах одного физического шарда. Это существенно облегчает обработку данных.</p>

<p>Например, в системах типа социальных сетей ключом для шардинга может быть ID пользователя, таким образом все данные пользователя будут храниться и обрабатываться на одном сервере, а не собираться по частям с нескольких.</p>

<h3>Чем отличаются SQL от NoSQL базы данных?</h3>

<p>В SQL-системах данные представляются в формате таблиц, тогда как в NoSQL — в формате </p>

<h4>документов</h4>

<p>Данные, которые представлены парами ключ-значение, могут сжиматься в виде хранилища документов. Реализация похожа на хранилище «ключ-значение», но разница в том, что в документоориентированной БД хранимые значения (документы) характеризуются определённой структурой и кодировкой данных (XML, JSON, BSON).</p>

<p>На сегодняшний день наиболее популярными документоориентированными СУБД являются Couchbase и MongoDB.</p>

<h4>графов</h4>

<p>Хранилище на основе графов — это сетевая NoSQL БД, использующая для отображения и хранения данных узлы и ребра. В ней вы не найдете строгого SQL-формата либо представления таблиц и колонок — вместо этого применяется гибкое графическое представление, прекрасно подходящее для решения проблем с масштабируемостью. Пример соответствующей СУБД — Neo4J.</p>

<p>Графовые структуры применяются совместно с ребрами, узлами и свойствами — таким образом обеспечивается безиндексная смежность. В случае применения графового хранилища вы сможете легко преобразовать данные из одной модели в другую.</p>

<p>такие БД используют для представления данных узлы и ребра;
между собой узлы связаны определенным отношениями, которые представлены ребрами;
узлы и отношения характеризуются рядом свойств.</p>

<p>Как это используется на практике?
Вспомните любой из рейтингов «Рекомендовано вам», которые есть на многих сайтах. Как правило, они формируются на основании оценки продукта пользователем. Как раз для такого случая и подходят графовые базы данных.</p>

<h4>пар «ключ-значение»</h4>

<p>Такие БД обычно используют хеш-таблицу, где присутствуют уникальный ключ и указатель на конкретный объект данных. Ключ бывает синтетическим либо автоматически сгенерированным, а значение бывает представлено JSON, строкой, блобом (Binary Large Object) и т. д.</p>

<p>Говоря о БД «ключ-значение», стоит упомянуть о таком понятии, как блок (bucket) — это логическая группа ключей, не группирующих данные физически. При этом в различных блоках бывают идентичные ключи. За счёт кеширующих механизмов, работающих на основе маппингов, производительность базы данных существенно вырастает. Дабы прочитать значение, надо знать и ключ, и блок, т. к. на деле ключ является хешем (блок, плюс ключ).</p>

<p>Несмотря на то, что БД типа «ключ-значение» неплохо себя зарекомендовали в определённых ситуациях, недостатки у них, разумеется, тоже присутствуют. Например, модель не предоставляет стандартные возможности для баз данных — допустим, атомарность транзакций либо согласованность данных при одновременном исполнении нескольких транзакций. То есть такие возможности должны предоставляться непосредственно самим приложением. Есть и второй существенный недостаток: когда происходит увеличение объёмов данных, поддерживать уникальные ключи становится проблемно. И чтобы эту проблему решить, надо каким-нибудь образом усложнять процесс генерации строк, дабы они оставались уникальными среди огромного набора ключей.</p>

<p>Redis, Memcache</p>

<h4>wide-column-хранилищ (Колоночная база данных NoSQL)</h4>

<p>В колоночных БД данные хранятся в ячейках, которые сгруппированы не в строки, а в колонки. Эти колонки логически группируются в соответствующие колоночные семейства, которые могут состоять, по сути, из неограниченного числа колонок (колонки могут создаваться либо во время работы программы, либо во время определения схемы). Запись и чтение осуществляются с применением колонок, а не строк.</p>

<p>Если сравнивать эту базу с хранением данных в строках, как это принято в большинстве реляционных БД, то у хранения в колонках есть свои плюсы. Например, быстрый поиск/доступ и агрегация данных. SQL-базы хранят каждую строку в виде непрерывной записи на диске, то есть различные строки хранятся в различных местах на диске. В случае с колоночной структурой, БД хранят все ячейки, которые относятся к колонке, в виде непрерывной записи — это и делает выполнение операций по поиску и доступу быстрее.</p>

<p>Простой пример: если мы захотим получить список заголовков нескольких миллионов статей, то при использовании SQL-баз это станет весьма трудоёмкой задачей, ведь для извлечения заголовков понадобится проходить по каждой записи. В случае с NoSQL мы сможем получить все заголовки посредством всего одной операции доступа к диску.</p>

<p>Колоночное семейство представляет собой структуру, которая может без проблем группировать колонки и суперколонки.
Ключ является постоянным именем записи. Ключи могут иметь различное число колонок, следовательно, БД способна расширяться неравномерно.
Есть термин пространства ключей. Это пространство определяет самый внешний уровень организации, обычно это имя приложения или имя БД.
Колонка характеризуется упорядоченным списком элементов, которые представляют собой кортежи со значениями и именами.</p>

<p>Наиболее известные примеры колоночных БД — ClickHouse, Google BigTable и HBase с Cassandra.</p>

<h3>Какие типы данных есть в MySQL?</h3>

<p>MySQL поддерживает типы данных SQL нескольких видов: числовые, типы даты и времени, строковые (символьные и байтовые) типы, пространственные типы и JSON типы данных.</p>

<h3>Разница между JOIN и UNION?</h3>

<p>UNION помещает строки из запросов друг за другом, а JOIN делает декартово произведение и подмножества - это совершенно разные операции.</p>

<h3>Что такое индексы? Как они влияют на время выполнения SELECT, INSERT?</h3>

<p>Индексы – это специальные таблицы, которые могут быть использованы поисковым двигателем базы данных (далее – БД), для ускорения получения данных. Необходимо просто добавить указатель индекса в таблицу. Индекс в БД крайне схож с индексом в конце книги.</p>

<p>Индекс помогает ускорить запросы на получение данных SELECT WHERE, но замедляет процесс добавления и изменения записей (INSERT, UPDATE). Индексы могут быть добавлены или удалены без влияния на сами данные.</p>

<h3>Что такое хранимые процедуры, функции и триггеры в MySQL? Для чего они? Приведите примеры использования.</h3>

<p>Функции не могут возвращать несколько результирующих наборов. Хранимая процедура может сформировать и вернуть несколько результирующих наборов данных</p>

<p>Хранимые процедуры представляют собой набор команд SQL, которые могут компилироваться и храниться на сервере. Таким образом, вместо того, чтобы хранить часто используемый запрос, клиенты могут ссылаться на соответствующую хранимую процедуру. Это обеспечивает лучшую производительность, поскольку данный запрос должен анализироваться только однажды и уменьшается трафик между сервером и клиентом. Концептуальный уровень можно также повысить за счет создания на сервере библиотеки функций.</p>

<p>Триггер представляет собой хранимую процедуру, которая активизируется при наступлении определенного события. Например, можно задать хранимую процедуру, которая срабатывает каждый раз при удалении записи из транзакционной таблицы - таким образом, обеспечивается автоматическое удаление соответствующего заказчика из таблицы заказчиков, когда все его транзакции удаляются.</p>

<h3>Как организовать сохранность вложенных категорий в MySQL?</h3>

<p>Можно использовать nullable столбец parent_id, указывающий на ID родительской категории, если она есть</p>

<h2>Laravel</h2>

<h3>Какие есть связи и как они реализуются в Laravel?</h3>

<p>Отношения Eloquent определяются как методы в классах модели Eloquent. Поскольку отношения реализованы поверх построителей запросов, использование отношений как методов (к примеру, не ->posts, а ->posts()) обеспечивает возможность создания цепочек методов и запросов.</p>

<h4>Один к одному</h4>

<h4>Один ко многим</h4>

<h4>Определение обратной связи Один ко многим</h4>

<h4>Один из многих</h4>

<h4>Один через отношение</h4>

<h4>Многие через отношение</h4>

<p>hasManyThrough</p>

<h4>Отношения Многие ко многим</h4>

<h4>Полиморфные отношения</h4>

<h4>Один к одному (полиморфное)</h4>

<p>Полиморфное отношение «один-к-одному» похоже на типичное «один-к-одному» отношение; однако, дочерняя модель может принадлежать более чем к одному типу моделей с помощью одной ассоциации. Например, блог Post и User могут иметь полиморфное отношение С моделью Image. Использование полиморфного «один-к-одному» отношения позволяет вам иметь единую таблицу уникальных изображений, которые могут быть связаны с постами и пользователями.</p>

<h4>Один ко многим (полиморфное)</h4>

<h4>Один из многих (полиморфное)</h4>

<h4>Многие ко многим (полиморфное)</h4>

<h4>Динамические отношения</h4>

<p>Вы можете использовать метод resolveRelationUsing для определения отношений между моделями Eloquent во время выполнения скрипта. Хотя обычно это не рекомендуется для нормальной разработки приложений, но иногда это может быть полезно при разработке пакетов Laravel.</p>

<h3>Что такое полиморфные связи, как они работают?</h3>

<p>Полиморфные отношения позволяют дочерней модели принадлежать более чем к одному типу модели с использованием одной ассоциации. Например, представьте, что вы создаете приложение, которое позволяет пользователям делиться постами и видео в блогах. В таком приложении модель Comment может принадлежать как к моделям Post, так и к Video.</p>

<h3>Что такое middleware? Зачем это? На каком этапе выполняется?</h3>

<p>Типичная обработка маршрута Laravel проходит через определенные этапы обработки запроса, а middleware - один из тех уровней, которым приложение должно пройти.</p>

<p>Laravel Middleware (посредник) выполняет функцию промежуточного звена между запросом и ответом. Это тип механизма фильтрации. Например, Laravel включает Middleware, которое проверяет подлинность пользователя приложения. Если пользователь аутентифицирован, он будет перенаправлен на главную страницу, в противном случае он будет перенаправлен на страницу входа в систему.</p>

<h2>Composer</h2>

<h3>Что такое Composer?</h3>

<p>Composer — это пакетный менеджер уровня приложений для языка программирования PHP, который предоставляет средства по управлению зависимостями в PHP-приложении.</p>

<h3>Чем отличается require от require-dev?</h3>

<p>В require добавляются зависимости, которые необходимы для работы пакета. В require-dev добавляются зависимости, которые нужны для разработки самого пакета. Например, phpunit/phpunit</p>


<h1>Middle</h1>

<h2>Общие вопросы</h2>

<h3>Как передаются переменные (по значению или по ссылке)?</h3>

<p>Согласно документации PHP, они передаются по значению. По умолчанию аргументы функций передаются по значению (таким образом, если значение аргумента внутри функции изменяется, оно не изменяется за пределами функции). Чтобы функция могла изменять свои аргументы, они должны передаваться по ссылке.</p>

<p>Объекты, переданные внутрь какой-то функции в качестве аргументов, ведут себя точно также – если внутри функции мы меняем внутреннее состояние объекта, то снаружи увидим это изменённое состояние. Отличие в том, что в сигнатуре функции не нужно ставить амперсанд перед параметром-объектом.</p>

<h3>Какие процессы происходят, когда пользователь вводит в браузере URL?</h3>

<p>todo https://habr.com/ru/company/htmlacademy/blog/254825/</p>

<h3>Что такое вариативная функция или splat-оператор?</h3>

<p>Вариативная функция - это функция с переменным числом аргументов</p>

<p>function listNumbers (...$numbers)</p>

<h3>Что такое OWASP?</h3>

<p>Open Web Application Security Project (OWASP) — это методология, открытый проект(сообщество) обеспечения безопасности веб-приложений.</p>

<p>В общем, есть несколько самых распространенных уязвимостей в PHP.</p>

<p>SQL injection. Метод заключается в вставке фрагмента SQL-инструкции в поля для ввода пользователем. Обычно для защиты можно ограничиться использованием PDO для работы с базой. В часности, использовать prepared statements.</p>

<p>XSS уязвимость (Cross Site Scripting). На клиенте внедряется свой js-код, который передается через форму (текстовое поле) на сервер. Далее это js может выполняться на других клиентах, которые открыли эту страничку. Таким образом можно отслеживать события на странице и собирать данные или перенаправлять на вредоносный сайт. Чтоб этого не допустить, нужно фильтровать(экранировать) данные, которые приходят от пользователя.</p>

<p>Провтыки в исходном коде, структуре проекта. Это могут быть конфигурационные файлы(например .env), которые открыты для пользователей. Нужно не допускать хранения важных файлов в каталогах доступных для всех пользователей (каталоги по типу /public или /web).</p>

<h3>Что такое идемпотентные методы? Какие HTTP-методы являются идемпотентными для REST?</h3>

<p>Метод HTTP является идемпотентным, если повторный идентичный запрос, сделанный один или несколько раз подряд, имеет один и тот же эффект, не изменяющий состояние сервера. Другими словами, идемпотентный метод не должен иметь никаких побочных эффектов (side-effects), кроме сбора статистики или подобных операций.</p>

<p>Методы GET, HEAD, OPTIONS и TRACE определены как безопасные, что также делает их идемпотентными.</p>

<h3>Что такое stateless?</h3>

<p>Stateless - состояние не хранится на сервере. Т. е. в каждом новом запросе мы передаём свой логин/пароль (если в приложении есть авторизация), а также данные для запроса.</p>

<p>Statefull - на сервере открывается сессия. Благодаря этому нам не надо постоянно отправлять на сервер логин/пароль. И не надо отсылать какие-то дополнительные данные (например выбранную локализацию), они хранятся в сессии.</p>

<h3>SOAP vs REST. В чем разница?</h3>

<p>SOAP API передает SOAP сообщения в стандартном формате XML из-за его statefulness, в то время как REST API не придерживается формата данных из-за его stateless. SOAP работает с WSDL благодаря формату XML, в то время как REST API использует такие запросы, как GET, PUT, POST, и DELETE.</p>

<h3>Какие методы авторизации используют для построения API?</h3>

<ul>
<li>API ключ</li>
<li>Basic Auth.</li>
<li>HMAC.</li>
<li>OAuth 2.0.</li>
</ul>

<h3>Что может содержать интерфейс?</h3>

<p>Интерфейсы могут содержать лишь сигнатуры методов - наазвания функций и список параметров в скобках, после которого идет точка с запятой. Так, в данном случае объявлен метод send() . Он не имеет реализации - конкретную реализацию определит класс, который реализует этот интерфейс.</p>

<h3>Класс содержит свойство, которое, в свою очередь, является объектом. Что будет содержать это свойство в клонированном объекте: ссылку на тот же дочерний объект или копию дочернего объекта? Что нужно сделать, чтобы это изменить?</h3>

<h3>Что такое Mock? Где используют и зачем?</h3>

<p>Mock-объект — в объектно-ориентированном программировании — тип объектов, реализующих заданные аспекты моделируемого программного окружения.</p>

<p>Mock-объекты активно используются в разработке через тестирование.</p>

<h3>Что такое PSR?</h3>

<p>PSR (PHP Standards Recommendations) — это набор рекомендаций по программированию на языке PHP. Основное назначение — предоставить проверенные общие концепции, чтобы сделать разработку простой и удобной, повысить надежность и работоспособность продуктов.</p>

<h3>Опишите реализацию одного из шаблонов проектирования.</h3>

<h3>Что такое Redis?</h3>

<p>Redis — резидентная система управления базами данных класса NoSQL с открытым исходным кодом, работающая со структурами данных типа «ключ — значение». Используется как для баз данных, так и для реализации кэшей, брокеров сообщений. Ориентирована на достижение максимальной производительности на атомарных операциях.</p>

<h3>Как хранятся данные в Redis / Memcached?</h3>

<p>В оперативной памяти</p>

<h3>Расскажите о целесообразности применения Redis / Memcached для кэширования. Каковы плюсы и минусы?</h3>

<p>Начнем со сходств. И Memcached, и Redis служат в качестве размещающихся в оперативной памяти хранилищ данных с ключом, хотя Redis более точно описывается как хранилище структуры данных. Как Memcached, так и Redis относятся к семейству решений для управления данными NoSQL, и оба они основаны на модели данных с ключевыми значениями. Они сохраняют все данные в ОЗУ (памяти), что, конечно же, делает их чрезвычайно полезными в качестве слоя кеширования. С точки зрения производительности два хранилища данных также очень похожи, демонстрируя почти идентичные характеристики (и показатели) в отношении пропускной способности и латентности.</p>

<p>Поскольку Redis новее и имеет больше возможностей, чем Memcached, Redis почти всегда лучший выбор. Тем не менее, Memcached может быть предпочтительнее при кэшировании относительно небольших и статических данных, таких как фрагменты кода HTML. Управление внутренней памятью Memcached, хотя и не столь сложное, как решение Redis, более эффективно в простейших случаях использования, поскольку оно потребляет сравнительно меньше ресурсов памяти для метаданных. Строки (единственный тип данных, поддерживаемый Memcached) идеально подходят для хранения данных, которые только читаются, потому что строки не требуют дальнейшей обработки.</p>

<p>Тем не менее, эффективность управления памятью Memcached быстро уменьшается, когда размер данных является динамическим, после чего память Memcached может стать фрагментированной. Кроме того, большие наборы данных часто включают в себя сериализованные данные, которые всегда требуют большего пространства для хранения. Хотя Memcached эффективно ограничивается хранением данных в его сериализованной форме, структуры данных в Redis могут сохранять любой аспект данных изначально, тем самым уменьшая накладные расходы на сериализацию.</p>

<p>Второй сценарий, в котором Memcached имеет преимущество перед Redis, находится в масштабировании. Поскольку Memcached многопоточен, вы можете легко увеличить его, предоставив ему больше вычислительных ресурсов, но вы потеряете часть или все кэшированные данные (в зависимости от того, используете ли вы постоянное хеширование). Redis, который в основном однопоточный, может масштабироваться горизонтально посредством кластеризации без потери данных. Кластеризация представляет собой эффективное масштабирующее решение, но его сравнительно сложно создавать и управлять им.</p>

<p>Кэши используют механизм, называемый выселением данных (синоним: вытеснение данных), чтобы освободить место для новых данных, удалив старые данные из памяти. Механизм выселения данных Memcached использует алгоритм Least Recent Used (LRU) и несколько произвольно вытесняет данные, похожие по размеру на новые данные.</p>

<h3>Назовите различия между nginx и Apache.</h3>

<p>Apache работает во всех операционных системах, таких как UNIX, Linux или BSD, и полностью поддерживает Microsoft Windows. Nginx также работает на нескольких современных Unix-подобных системах и поддерживает Windows, но его производительность в Windows не так стабильна, как на платформах UNIX.</p>

<p>Одно из самых существенных отличий между Apache и Nginx состоит в том как они обрабатывают соединения и отвечают на различные виды трафика.</p>

<p>Если рассматривать жизненные примеры, то основные различия между Apache и Nginx в том как они обрабатывают запросы к статическому и динамическому контенту.</p>

<p>Apache может раздавать статический контент используя стандартные file-based методы. Производительность таких операций зависит от выбранного MPM.</p>

<p>Apache также может раздавать динамический контент встраивая интерпретатор нужного языка в каждого воркера. Это позволяет обрабатывать запросы к динамическому содержимому средствами самого веб-сервера и не полагаться на внешние компоненты. Интерпретаторы языков могут быть подключены к Apache с помощью динамически загружаемых модулей.</p>

<p>Возможность обрабатывать динамический контент средствами самого Apache упрощает конфигурирование. Нет необходимости настраивать взаимодействие с дополнительным софтом, динамический модуль может быть легко отключен в случае изменившихся требований.</p>

<p>Nginx не имеет возможности самостоятельно обрабатывать запросы к динамическому контенту. Для обработки запросов к PHP или другому динамическому контенту Nginx должен передать запрос внешнему процессору для исполнения, подождать пока ответ будет сгенерирован и получить его. Затем результат может быть отправлен клиенту.</p>

<p>Для администраторов это означает, что нужно настроить взаимодействие Nginx с таким процессором используя один из протоколов, который известен Nginx'у (http, FastCGI, SCGI, uWSGI, memcache). Это может немного усложнить процесс настройки, в особенности когда вы будете пытаться предугадать какое число соединений разрешить, так как будет использоваться дополнительное соединение с процессором на каждый пользовательский запрос.</p>

<p>Однако, этот метод имеет и свои преимущества. Так как интерпретатор не встроен в каждого воркера, то оверхед, связанный с этим, будет иметь место только при запросах к динамическому контенту. Статический контент будет возвращен клиенту простым способом и запросы к интерпретатору будут выполняться только тогда когда они нужны. Apache тоже может работать в такой манере, но тогда это лишит его всех преимуществ описанных в предыдущем разделе.</p>

<h3>Что такое Opcash? Как он работает?</h3>

<p>Zend Opcache – это расширение PHP, предназначенное для повышения производительности PHP, сокращения времени загрузки веб-страниц и уменьшения нагрузки на сервере.</p>

<p>Производительность достигается путем компиляции кода PHP файлов при первом обращении к ним. В результате при следующем доступе сервер не тратит ресурсы на повторное чтение и компиляцию php файла, а отдает готовый результат из кэша opcache. Т.е. opcache дает хорошие результаты для cms/файлов php скриптов, код которых редко изменяется.</p>

<h3>Что такое JIT? Как он работает?</h3>

<p>JIT-компиляция (англ. Just-in-Time, компиляция «точно в нужное время»), динамическая компиляция (англ. dynamic translation) — технология увеличения производительности программных систем, использующих байт-код, путём компиляции байт-кода в машинный код или в другой формат непосредственно во время работы программы.</p>

<p>Упрощая вещи: когда JIT работает должным образом, ваш код не будет выполняться через Zend VM, вместо этого он будет выполняться непосредственно как набор инструкций уровня процессора.</p>

<h3>Зачем нужно ключевое слово final?</h3>

<p>PHP предоставляет ключевое слово final , разместив которое перед объявлениями методов или констант класса, можно предотвратить их переопределение в дочерних классах. Если же сам класс определяется с этим ключевым словом, то он не сможет быть унаследован.</p>

<h3>Что такое SOLID, DRY, KISS, YAGNI?</h3>

<p>DRY - Don`t repeat yourself</p>

<p>это принцип разработки программного обеспечения, нацеленный на снижение повторения информации различного рода, особенно в системах со множеством слоёв абстрагирования.</p>

<p>KISS - keep it simple stupid</p>

<p>Делай код проще. принцип проектирования, принятый в ВМС США в 1960. Принцип KISS утверждает, что большинство систем работают лучше всего, если они остаются простыми, а не усложняются. Поэтому в области проектирования простота должна быть одной из ключевых целей, и следует избегать ненужной сложности.</p>

<p>YAGNI — процесс и принцип проектирования ПО, при котором в качестве основной цели и/или ценности декларируется отказ от избыточной функциональности, — то есть отказ добавления функциональности, в которой нет непосредственной надобности</p>

<h3>Назовите паттерны проектирования, с которыми приходилось работать.</h3>

<h3>Что такое простая фабрика?</h3>

<h3>Что такое Service Layer и где его следует применять?</h3>

<p>Сервисный слой (Service layer) — это шаблон проектирования, который поможет вам абстрагировать логику от логики предметной области (domain logic), при необходимости использования разных интерфейсов. На самом деле вы делегируете логику приложения общему сервису (сервисному слою) и обслуживаете только один класс.</p>

<p>Если простыми словами, то вы сосредотачиваете логику вашего приложения в одном (или нескольких) классе-сервисе, а в своих контроллерах обращаетесь к нему. Это избавляет от дублирования кода в разных участках системы, делая ваш контроллер действительно соответствующим букве S из SOLID.</p>

<h3>Как устроен Singleton и почему его считают антипаттерном?</h3>

<p>Singleton относится к порождающим паттернам. Его дословный перевод – одиночка.  Этот паттерн гарантирует, что у класса есть только один объект (один экземпляр класса) и к этому объекту предоставляется глобальная точка доступа.</p>

<ul>
<li>Синглтон нарушает SRP (Single Responsibility Principle) — класс синглтона, помимо того чтобы выполнять свои непосредственные обязанности, занимается еще и контролированием количества своих экземпляров.</li>
<li>Глобальное состояние. Про вред глобальных переменных вроде бы уже все знают, но тут та же самая проблема. Когда мы получаем доступ к экземпляру класса, мы не знаем текущее состояние этого класса, и кто и когда его менял, и это состояние может быть вовсе не таким, как ожидается. Иными словами, корректность работы с синглтоном зависит от порядка обращений к нему, что вызывает неявную зависимость подсистем друг от друга и, как следствие, серьезно усложняет разработку.</li>
<li>Зависимость обычного класса от синглтона не видна в публичном контракте класса. Так как обычно экземпляр синглтона не передается в параметрах метода, а получается напрямую, через GetInstance(), то для выявления зависимости класса от синглтона надо залезть в тело каждого метода — просто просмотреть публичный контракт объекта недостаточно.</li>
<li>Наличие синглтона понижает тестируемость приложения в целом и классов, которые используют синглтон, в частности. Во-первых, вместо синглтона нельзя подпихнуть Mock-объект, а во-вторых, если синглтон имеет интерфейс для изменения своего состояния, то тесты начинают зависеть друг от друга. Говоря же проще — синглтон повышает связность, и все вышеперечисленное, в том или ином виде, есть следствие повышения связности.</li>
</ul>

<h3>Что такое идемпотентность?</h3>

<p>Идемпотентность — свойство объекта или операции при повторном применении операции к объекту давать тот же результат, что и при первом.</p>

<h3>Опишите жизненный цикл HTTP-запроса.</h3>

<h3>Что такое куча и стек?</h3>

<p>Стек — это область оперативной памяти, которая создаётся для каждого потока. Он работает в порядке LIFO (Last In, First Out),  то есть последний добавленный в стек кусок памяти будет первым в очереди на вывод из стека. Каждый раз, когда функция объявляет новую переменную, она добавляется в стек, а когда эта переменная пропадает из области видимости (например, когда функция заканчивается), она автоматически удаляется из стека. Когда стековая переменная освобождается, эта область памяти становится доступной для других стековых переменных.</p>

<p>Куча — это хранилище памяти, также расположенное в ОЗУ, которое допускает динамическое выделение памяти и не работает по принципу стека: это просто склад для ваших переменных. Когда вы выделяете в куче участок памяти для хранения переменной, к ней можно обратиться не только в потоке, но и во всем приложении. Именно так определяются глобальные переменные. По завершении приложения все выделенные участки памяти освобождаются. Размер кучи задаётся при запуске приложения, но, в отличие от стека, он ограничен лишь физически, и это позволяет создавать динамические переменные.</p>

<h3>Что такое рефлексия?</h3>

<p>PHP включает в себя полноценный Reflection API, который предоставляет возможность проводить интроспекцию классов, интерфейсов, функций, методов и модулей. Кроме того, Reflection API позволяет получать doc-блоки комментариев функций, классов и методов.</p>

<ul>
<li>для аннотаций (получения данных из phpdoc)</li>
<li>IoC-контейнеры, например, в Laravel.</li>
<li>позволяет тестировать private методы классов напрямую.</li>
</ul>

<p>рефлексия всего лишь позволяет программе отслеживать свою структуру и поведение во время выполнения.</p>

<h3>Что такое хэш-функция и где она используется?</h3>

<p>Хеширование — операция, которая преобразует любые входные данные в строку (реже число) фиксированной длины. Функция, реализующая алгоритм преобразования, называется "хеш-функцией", а результат называют "хешем" или "хеш-суммой". Наиболее известны CRC32, MD5 и SHA (много разновидностей).</p>

<p>Например, для хеширования паролей, чтобы не хранить их в явном виде. Развернуть пароль из хеша, особенно, если хеш создан по сложному алгоритму, очень сложно.</p>

<p>Так же, можно использовать хеши для уникализации каких-либо данных, вместо того, чтобы сравнивать большие строки, можно сравнивать их заранее подготовленные хеши.</p>

<h3>Как применяются очереди в РНР?</h3>

<h3>Как в общих чертах работает OPcache?</h3>

<h3>Что такое TDD?</h3>

<p>Разработка через тестирование — техника разработки программного обеспечения, которая основывается на повторении очень коротких циклов разработки: сначала пишется тест, покрывающий желаемое изменение, затем пишется код, который позволит пройти тест, и под конец проводится рефакторинг нового кода к соответствующим</p>

<h3>Чем отличаются модульные тесты от интеграционных?</h3>

<p>Тест интеграции отличается от модульного теста тем, что он позволяет двум или более программным компонентам работать совместно, также называемый интеграцией. Эти тесты работают в более широком спектре тестируемой системы, в то время как модульные тесты сосредоточены на отдельных компонентах.</p>

<h3>Что такое трейты? Как применять на практике?</h3>

<p>Трейты — альтернативный механизм переиспользования общего кода в разных классах. Он устраняет ограничения, которыми обладает наследование и заменяет его. Трейты похожи на абстрактные классы. Они реализуют какую-то общую функциональность и с ними нельзя работать напрямую.</p>

<h3>Как разрешить конфликты при использовании trait?</h3>

<p>Ошибки могут быть когда подключается несколько трейтов, содержащие одни и те же методы. Или когда класс наследует у другого класса с подключением трейта, который уже был подключен в родительском классе.
Для разрешения конфликтов необходимо использовать оператор insteadof при подключении трейтов для того, чтобы точно выбрать один из конфликтных методов.
Внутри тела «use» мы использовали ключевое слово insteadof, слева от которого указывается трейт, метод которого будем использовать и имя самого метода, которые разделяются двойным двоеточием. В правой части указывается имя трейта, метод которого должен быть заменён.</p>

<p>Если же второй одноименный метод (из другого трейта) нам тоже нужен, то можно применить псевдоним имени используя ключевое слово as</p>

<h3>Как работает автозагрузка классов?</h3>

<p>PHP содержит специальный механизм автозагрузки классов. Этот механизм работает так: если интерпретатор наталкивается на использование класса, то он проверяет, определили ли вы автозагрузчик классов, и, если определили, то вызывает его (пример). Composer определяет такой загрузчик автоматически.</p>

<p>Большинство разработчиков объектно-ориентированных приложений используют такое соглашение именования файлов, в котором каждый класс хранится в отдельно созданном для него файле. Одна из самых больших неприятностей - необходимость писать в начале каждого скрипта длинный список подгружаемых файлов (по одному для каждого класса).</p>

<p>Функция spl_autoload_register() позволяет зарегистрировать необходимое количество автозагрузчиков для автоматической загрузки классов и интерфейсов, если они в настоящее время не определены. Регистрируя автозагрузчики, PHP получает последний шанс для интерпретатора загрузить класс прежде, чем он закончит выполнение скрипта с ошибкой.</p>

<p>Любая конструкция, подобная классу может быть автоматически загружена таким же образом, включая классы, интерфейсы, трейты и перечисления.</p>

<h3>В чем разница между стеком и очередью?</h3>

<p>Очереди очень похожи на стеки. Они также не дают доступа к произвольному элементу, но, в отличие от стека, элементы кладутся (enqueue) и забираются (dequeue) с разных концов. Такой метод называется «первый вошел, первый вышел» (First-In-First-Out или FIFO).</p>

<h3>Расскажите о Unit Tests (required), Functional Tests (optional). Моки и стаб в PHP.</h3>

<h3>Представим ситуацию, в которой нам нужно вызвать частный метод. Как это сделать?</h3>

<p>Можно через рефлексию.</p>

<h3>Опишите разницу между PHP-FPM и PHP на сокете.</h3>

<p>PHP-FPM - это PHP-реализация FastCGI; PHP-FPM работает как самостоятельный сервер FastCGI, и Apache подключается к серверу с помощью модуля Apache, обычно mod_fcgid или mod_fastcgi. Это лучше, чем запускать PHP через mod_php. В этой конфигурации права доступа и все остальное выполняется в конфигурации PHP.</p>

<h3>Как бы вы реализовали загрузки больших отчетов с большим количеством данных (файлы от 1 гигабайта до N гигабайт).</h3>

<h3>Как бы вы импортировали 50-гигабайтный файл xml в базу данных?</h3>

<h3>Почему после PHP 5 идет сразу 7, куда делась 6?</h3>

<p>в марте 2010 года разработка PHP6 была признана бесперспективной из-за сложностей с поддержкой Юникода.</p>

<h3>Есть ли разница между self и this в PHP?</h3>

<p>Статические функции должны использовать только статические переменные.</p>

<ul>
<li>self ТОЛЬКО для статических функций, свойств. Но также можно вызвать нестатический метод, КАК СТАТИЧЕСКИЙ через self. Но лучше так не делать, а то папа побьет.</li>
<li>this ТОЛЬКО для нестатических.</li>
<li>this требует, чтобы класс был проинстанцирован, self не требует.</li>
<li>$this - это ССЫЛКА на ТЕКУЩИЙ объект и она нужна, чтобы обратиться к переменной в КОНТЕКСТЕ класса.</li>
</ul>

<h3>Что такое PuTTY?</h3>

<p>свободно распространяемый клиент для различных протоколов удалённого доступа, включая SSH, Telnet, rlogin. Также имеется возможность работы через последовательный порт.</p>

<h3>У нас есть важный PHP-файл, его надо запускать каждые 20 секунд. Как бы вы это сделали?</h3>

<p>несколько кронов вида</p>

<pre>
* * * * * php myscript.php
* * * * * sleep 20 && php myscript.php
* * * * * sleep 40 && php myscript.php
</pre>

<h3>Как расшифровать 644 в правах на файл в Linux?</h3>

<p>Для каждой группы пользователей определены свои права доступа. При попытке соединения веб-сервер определяет, к какой группе отнести того или иного юзера. Все они разделяются на:</p>

<ul>
<li>«user» (u) — владелец файла;</li>
<li>«group» (g) — один из членов группы, к которой принадлежит и владелец;</li>
<li>«others» (o) — все остальные пользователи.</li>
</ul>

<p>Права доступа к файлам позволяют производить следующие операции с объектами:</p>

<ul>
<li>r (read) = 4 — чтение (возможность просмотра содержания);</li>
<li>w (write) = 2 — запись, перезапись (изменение содержимого), но не удаление;</li>
<li>x (eXutive) = 1 — исполнение (например, запуск программного файла).    </li>
<li>нет прав = 0</li>
</ul>

<p>права складываются</p>

<p>644 = 6(user чтение + запись) + 4 (группа чтение) + 4 (остальные чтение)</p>

<h2>Git</h2>

<h3>В чем разница между merge и rebase?</h3>

<p>Согласно официальному руководству Git rebase “повторно применяет коммиты поверх другой базовой ветки”, тогда как merge “объединяет две или более историй разработки”. Иначе говоря, основное отличие между ними в том, что слияние сохраняет историю в первозданном виде, а перебазирование ее перезаписывает.</p>

<h3>Какой командой можно сделать ресет изменений, не потеряв их?</h3>

<h3>Что такое stash и зачем он нужен?</h3>

<p>Команда git stash позволяет на время «сдать в архив» (или отложить) изменения, сделанные в рабочей копии, чтобы вы могли применить их позже. Откладывание изменений полезно, если вам необходимо переключить контекст и вы пока не готовы к созданию коммита.</p>

<h2>Базы данных</h2>

<h3>В чем разница между MyISAM i InnoDB? Что в каких случаях лучше применять?</h3>

<h3>Как найти и оптимизировать «тяжелые» запросы?</h3>

<h3>Какие есть типы индексов?</h3>

<h3>Как хранить координаты точки на карте в БД?</h3>

<h3>Какие типы индексов бывают в RDBMS?</h3>

<h3>Какое свойство полей БД нужно учитывать при выборе типа индекса?</h3>

<h3>Когда следует использовать индексы, какие есть преимущества и недостатки?</h3>

<h3>Что такое ACID?</h3>

<h3>Что такое план выполнения запроса и как его узнать?</h3>

<h3>В чем разница между типами данных CHAR и VARCHAR в SQL?</h3>

<h3>Каково назначение транзакций? Расскажите о принципе работы.</h3>

<h3>Назовите 3-4 нормальные формы реляционных БД.</h3>

<h3>Каково назначение репликации? Какие есть типы связей и в чем разница между ними?</h3>

<h3>Что такое индексация? Какие есть типы индексов? Какой смысл их использовать?</h3>

<h3>Что такое полнотекстовый поиск в MySQL? Как он реализуется?</h3>

<h3>Что такое cursor в MySQL-процедурах?</h3>

<h3>Расскажите о RabbitMQ или Gearman.</h3>

<h3>Что знаете о Solr / ElasticSearch?</h3>

<h3>Что такое Дедлок MySQL?</h3>

<h3>Влияет ли порядок JOIN на план выполнения MySQL-запроса?</h3>

<h2>Laravel</h2>

<h3>Как и какие запросы формируются при использовании метода with()?</h3>

<h3>Чем отличаются методы with() и load()?</h3>


<h1>Senior</h1>

<h2>Общие вопросы</h2>

<h3>Как вы понимаете REST?</h3>

<p>REST (Representational state transfer) – это стиль архитектуры программного обеспечения для распределенных систем, таких как World Wide Web, который, как правило, используется для построения веб-служб. Термин REST был введен в 2000 году Роем Филдингом, одним из авторов HTTP-протокола. Системы, поддерживающие REST, называются RESTful-системами.</p>

<p>В общем случае REST является очень простым интерфейсом управления информацией без использования каких-то дополнительных внутренних прослоек. Каждая единица информации однозначно определяется глобальным идентификатором, таким как URL. Каждая URL в свою очередь имеет строго заданный формат.</p>

<h3>Что такое Copy-on-write?</h3>

<p>Идея подхода copy-on-write заключается в том, что при чтении области данных используется общая копия, в случае изменения данных — создается новая копия.</p>

<p>Как известно основным отличием ссылочных типов от типов значений является то, что первые передаются по ссылкам, в то время как вторые копируются. У этого есть ряд своих плюсов таких как то, что типы значений работают быстрее, потому что хранятся на стеке, а не в куче, используют статическую диспетчеризацию и прочее. Однако можно задаться вопросом “а зачем копировать данные, если мы их не меняем?”. Действительно и COW как раз-таки отвечает на этот вопрос и говорит, что это не обязательно.</p>

<p>Обе переменные ссылаются на одну область памяти, хотя мы и работаем с типом значений и данные первой переменной должны были бы копироваться во вторую.</p>

<h3>Что такое позднее статическое связывание?</h3>

<p>В отличие от $this, обращение к статическим свойствам и методам через self работает по принципу раннего связывания (обратное позднему). Другими словами, self указывает на тот класс, в котором идёт обращение</p>

<p>Функциональность позднего статического связывания, позволяет объектам все также наследовать методы у родительских классов, но помимо этого дает возможность унаследованным методам иметь доступ к статическим константам, методам и свойствам класса потомка, а не только родительского класса</p>

<h3>Что такое CQRS?</h3>

<p>CQRS — это стиль архитектуры, в котором операции чтения отделены от операций записи. Подход сформулировал Грег Янг на основе принципа CQS, предложенного Бертраном Мейером. Чаще всего (но не всегда) CQRS реализуется в ограниченных контекстах (bounded context) приложений, проектируемых на основе DDD. Одна из естественных причин развития CQRS — не симметричное распределение нагрузки и сложности бизнес-логики на read и write — подсистемы Большинство бизнес-правил и сложных проверок находится во write — подсистеме. При этом читают данные зачастую в разы чаще, чем изменяют.</p>

<h3>Что такое cohesion и coupling?</h3>

<p>Cohesion представляет собой степень, в которой часть кодовой базы образует логически единую атомарную единицу (юнит).</p>

<p>Он также может указать на количество связей внутри некоторой кодовой единицы. Если число мало, то, вероятно, границы для блока выбраны неправильно, код внутри блока логически не связан.</p>

<p>Блок (юнит) здесь необязательно является классом. Это может быть метод, класс, группа классов или даже модуль: понятие cohesion (а также coupling) применимо на разных уровнях.</p>

<p>С другой стороны, coupling представляет собой степень взаимосвязи между блоками. Другими словами, это количество соединений между двумя или более блоками. Чем меньше число, тем ниже coupling.</p>

<p>По сути, высокий cohesion означает хранение связанных друг с другом частей кода в одном месте. В то же время низкий coupling заключается в максимально возможном разделении несвязанных частей кодовой базы.</p>

<h3>Как можно получить значение частного свойства класса в рантайме?</h3>

<h3>Как можно получить значение частного свойства класса в рантайме без использования рефлексии?</h3>

<h3>Стоит ли использовать в методах значение по умолчанию null? Если нет, то почему?</h3>

<h3>Стоит ли возвращать null из методов? Если нет, то почему и как писать код в таких случаях?</h3>

<p>Возвращая null, мы фактически создаем для себя лишнюю работу, а для вызывающей стороны — лишние проблемы. Стоит пропустить всего одну проверку null, и приложение «уходит в штопор».</p>

<h3>Стоит ли передавать null как параметр методов? Если нет, то почему и как писать код?</h3>

<h3>Как вы понимаете Special Case / Null Object и где его следует применять?</h3>

<h3>Какой подход следует применить во время тестирования кода, имеющего внешние зависимости (например, обращение к API Google)?</h3>

<h3>Что такое DDD?</h3>

<p>Domain driven design (DDD) — подход к разработке приложений, основанный на выделении доменов (domain).</p>

<p>Домен — область знаний/деятельности, для которой разрабатывается приложение. Ясно, что для юристов есть свои термины и важные понятия, которые отличаются от слов, используемых в нефтегазовой промышленности. Причем это не просто слова, они отражают важные для заказчика процессы, связи. Именно поэтому важно уделять внимание терминам, которые используются в данной сфере. Это обеспечивается постоянным общением двух сторон — разработчиков приложения и клиентов. Такой подход отражает главный принцип DDD — разработка не должна быть в отрыве от бизнес-задач. DDD не является инструкцией или методологией, а составляет набор правил и ориентиров.</p>

<h3>Что такое микросервисная архитектура?</h3>

<p>Микросервисная архитектура — вариант сервис-ориентированной архитектуры программного обеспечения, направленный на взаимодействие насколько это возможно небольших, слабо связанных и легко изменяемых модулей — микросервисов, получивший распространение в середине 2010-х годов в связи с развитием практик гибкой разработки</p>

<h3>Какие есть способы коммуникации между микросервисамы?</h3>

<h3>Расскажите о ReactPHP или Swoole.</h3>

<h3>Что такое фильтр Блума?</h3>

<p>Фильтр Блума — это вероятностная структура данных, придуманная Бёртоном Блумом в 1970 году, позволяющая проверять принадлежность элемента к множеству. При этом существует возможность получить ложноположительное срабатывание, но не ложноотрицательное.</p>

<h3>Что такое gap locks в MySQL?</h3>

<h3>Зачем нужно кэширование? Какую проблему оно решает?</h3>

<h3>Какие виды кеш-хранилищ вы знаете и применяли? Чем они отличаются?</h3>

<h3>Чем характеризуется эффективность кэширования?</h3>

<h3>Приведите сложный пример кэширования на практике.</h3>

<h3>Что такое sensitive данные? Как хранятся в базе? Как отражаются в логах?</h3>

<h3>Коротко расскажите об истории PHP. Что появлялось в каждой версии? Куда развивается PHP на ваш взгляд? Что нового в последней версии?</h3>

<h3>Как в PHP очистить память?</h3>

<p>gc_collect_cycles — Принудительный запуск сборщика мусора</p>

<h3>Что такое антипаттерны? Приведите несколько примеров.</h3>

<h3>Как сделать рефакторинг большого legacy-проекта? Как это аргументировать / продать PM-у, заказчику?</h3>

<h3>Чем отличается Dependency Injection от Service Locator?</h3>

<h3>Расскажите об утечке памяти в PHP. Приведите примеры. Как боролись?</h3>

<h3>Как работает Garbage Collector? Когда есть смысл вызвать?</h3>

<h3>По какому принципу будете выбирать архитектуру для своей будущей программы?</h3>

<h3>С какими видами архитектуры приложений сталкивались?</h3>

<h3>Структуры данных. Какие знаете, какие использовали на практике?</h3>

<h3>С какими еще видами API сталкивались? Какие были проблемы? Как решали?</h3>

<h3>Как вы понимаете Exception flow в контексте PHP?</h3>

<h3>Расскажите об автоматических анализаторах кода PHP (Roundcube т.д.).</h3>

<h3>Расскажите о Performance &amp; профилировании PHP-кода (Xdebug, XHprof т.д.).</h3>

<h3>Расскажите, как бы вы реализовали систему, когда есть много источников данных, возвращающих в различных форматах данные о пользователе. Есть получатели данных, выбирающие, из каких источников они хотят принимать данные API.</h3>

<h3>Как вы организуете тестирование кода? Когда покрытие тестами нерационально? Были ли у вас такие проекты?</h3>

<h2>Git</h2>

<h3>Как изменить только сообщение последнего коммита?</h3>

<h3>git rebase -i HEAD ~ 3 что делает эта команда и какие могут возникнуть проблемы при ее применении?</h3>

<h3>Зачем команда git bundle?</h3>

<h3>Какой командой можно влить коммит в текущую ветку?</h3>

<h3>Как выполнить склеивание коммитов?</h3>

<h2>Базы данных</h2>

<h3>Какие структуры данных поддерживает Redis?</h3>

<h3>Что подразумевается под понятием «триггер» в SQL?</h3>

<p>Триггеры представляют специальный тип хранимой процедуры, которая вызывается автоматически при выполнении определенного действия над таблицей или представлением, в частности, при добавлении, изменении или удалении данных, то есть при выполнении команд INSERT, UPDATE, DELETE</p>

<h3>Какая разница между реляционными и нереляционными СУБД?</h3>

<p>Реляционные БД используют язык SQL (структурированных запросов). Структура таких баз данных позволяет связывать информацию из разных таблиц с помощью внешних ключей (или индексов), которые используются для уникальной идентификации любого атомарного фрагмента данных в этой таблице. Другие таблицы могут ссылаться на этот внешний ключ, чтобы создать связь между частями данных и частью, на которую указывает внешний ключ.</p>

<p>Они отличаются от реляционных тем, что в них для хранения используется не система из строк и столбцов, а применяется модель, которая оптимизирована для хранения определённого типа содержимого. Например, данные могут храниться в виде документов JSON, графов, а также ключей-значений.</p>

<h3>Какие NoSQL СУБД знаете?</h3>

<h3>Что такое ACID Compliance?</h3>

<h3>Что такое Views? Какие преимущества и недостатки?</h3>

<h3>Что такое уровни изоляции транзакций?</h3>

<h3>Что такое concurrent query?</h3>

<h3>Что такое кластерные индексы?</h3>

<h3>Как построить социальную сеть, которая выдержит нагрузки в 100 000 посетителей в онлайне и сможет предлагать в друзья пользователям, например, из Нью-Йорка, людей, живущих в этом городе. Данных много, работать система должна быстро. Как все хранить? По какому принципу строить запросы?</h3>


<h1>LARAVEL</h1>

<h2>Backend/WEB</h2>

<h3>Что вы знаете о CORS?</h3>

<p>CORS (Cross-Origin Resource Sharing, англ. «совместное использование ресурсов разных источников») — это стандарт, позволяющий предоставлять веб-страницам доступ к объектам сторонних интернет-ресурсов.
Сторонним считается любой интернет-ресурс, который отличается от запрашиваемого протоколом, доменом или портом.</p>

<p>Доступ предоставляется по специализированным запросам. Интернет-ресурс, принимающий запрос, содержит список доверенных источников, которым разрешен доступ к объектам. Страница-источник запроса получает доступ, если входит в список доверенных источников. Для предоставления доступа всем сторонним интернет-страницам используется маска «*».</p>

<h3>Перечислите преимущества HTTP/2 над HTTP 1.1;</h3>

<p>HTTP 1.1 позволяет обрабатывать лишь один поступивший запрос на одно TCP-соединение, поэтому браузеру приходится устанавливать несколько соединений, чтобы обрабатывать одновременно несколько запросов.</p>

<p>Особенности HTTP/2</p>

<ul>
<li>Мультиплексированные потоки</li>
<li>Отправка данных по инициативе сервера (Server Push)</li>
<li>Используются улучшенные алгоритмы сжатия заголовков, что повышает производительность и безопасность.</li>
<li>Улучшенные механизмы приоритезации потоков.</li>
<li>Быстрое шифрование.</li>
</ul>

<h3>Что такое репликация данных В БД?</h3>

<h3>Расскажите о шардинге</h3>

<h4>Вертикальный шардинг</h4>

<p>Вертикальный шардинг — это выделение таблицы или группы таблиц на отдельный сервер.</p>

<p>Например, в приложении есть такие таблицы:</p>

<ul>
<li>users — данные пользователей</li>
<li>photos — фотографии пользователей</li>
<li>albums — альбомы пользователей
Таблицу users Вы оставляете на одном сервере, а таблицы photos и albums переносите на другой. В таком случае в приложении Вам необходимо будет использовать соответствующее соединение для работы с каждой таблицей</li>
</ul>

<h4>Горизонтальный шардинг</h4>

<p>Горизонтальный шардинг — это разделение одной таблицы на разные сервера. Это необходимо использовать для огромных таблиц, которые не умещаются на одном сервере. Разделение таблицы на куски делается по такому принципу:</p>

<ul>
<li>На нескольких серверах создается одна и та же таблица (только структура, без данных).</li>
<li>В приложении выбирается условие, по которому будет определяться нужное соединение (например, четные на один сервер, а нечетные — на другой).</li>
<li>Перед каждым обращением к таблице происходит выбор нужного соединения.</li>
</ul>

<h3>Перечислите основные уязвимости которые могу появиться при разработки Web приложения;</h3>

<h3>Какие основные типы ошибок в PHP и чем они отличаются?</h3>

<p>Ошибки в PHP бывают:</p>

<ul>
<li>фатальные (fatal);</li>
<li>не фатальные;</li>
<li>пользовательские.</li>
</ul>

<h4>Fatal error в PHP</h4>

<p>одна из наиболее серьезных проблем. Такие дефекты появляются и при компиляции, и во время работы парсера либо PHP-скрипта. Основной нюанс заключается в том, что происходит прерывание исполнения скрипта.</p>

<ul>
<li>E_PARSE. Грубый недостаток в синтаксисе. PHP-интерпретатор не понимает, что вы вообще от него хотите.</li>
<li>Интерпретатор PHP понимает, что хочет разработчик, но выполнить это не может по разным причинам. Выполнение скрипта будет прервано, однако произойдет именно в месте возникновения проблемы, то есть код сработает до того места, где находится ошибка. Примеры: не удалось обнаружить подключаемый файл PHP; было выброшено, но не было обработано исключение; разработчик пытался вызвать метод класса, причем данный метод не существует; отсутствует свободная память (превышен лимит директивы memory_limit).</li>
</ul>

<h4>Не фатальные</h4>

<p>В данном случае выполнение скрипта не прерывается, однако именно эти дефекты часто находят тестировщики программного обеспечения.</p>

<ul>
<li>E_WARNING</li>
<li>E_NOTICE: обращение к неопределенной переменной; обращение к элементу массива, когда элемент не существует; обращение к несуществующей константе; проблема, возникающая, если не конвертируются типы данных и т. п.</li>
<li>E_DEPRECATED. Язык программирования PHP станет ругаться при использовании устаревших функций (т. е. функций, которые помечены в качестве deprecated);</li>
<li>E_STRICT. Это тоже история про то, что нужно писать код правильно и обращать внимание на подсказки со стороны IDE, дабы потом не было мучительно больно и стыдно. К примеру, если вы вызовете нестатический метод как статику, код, отображенный ниже, функционировать будет, но ведь это как-то неправильно.</li>
</ul>

<h4>Пользовательские</h4>

<p>E_USER_WARNING — некритическая ошибка;
E_USER_ERROR — критическая;
E_USER_NOTICE — речь идет о сообщениях, которые ошибками не являются.
Отдельно надо сказать про E_USER_DEPRECATED — напоминает о том, что  метод либо функция устарели, то есть пришло время переписать код.</p>

<pre>
/**
 * @deprecated
 */
function fun() 
{
  //do smthing
}
</pre>

<h3>Что такое Contract'ы в экосистеме Laravel?</h3>

<h3>Перечислите типы отношений в Eloquent;</h3>

<h3>Расскажете о жизненном цикле запроса в Laravel;</h3>

<h3>Какие, по вашему мнению, главные недостатки Eloquent ORM?</h3>

<p>Согласно принципу, доменный объект должен иметь только одну зону ответственности, то есть только свою бизнес-логику. Вызывая его для сохранения данных, вы добавляете ему дополнительную зону ответственности, увеличивая сложность объекта, что усложняет его поддержку и тестирование.</p>

<h3>Что такое Facade? Какие плюсы и минусы вы можете отметить у этого шаблона?</h3>

<h3>Напишите реализацию Singleton через контейнер зависимостей Laravel;</h3>

<h3>Что такое «Нетерпеливая загрузка» в Eloquent?</h3>

<p>В Eloquent отношения имеют функцию "ленивой загрузки". То есть они загружаются только при обращении к свойствам. Но помимо этого можно "нетерпеливо" загружать отношения во время загрузки родительской модели. Такая загрузка решает проблему N+1 запроса.  </p>

<pre>
class Book extends Model {
   public function author() {
      return $this->belongsTo('App\Author');
   }
}
</pre>

<p>Для получения имён авторов используется такой цикл:</p>

<pre>
$books = App\Book::all();

foreach ($books as $book) {
   echo $book->author->name;
}
</pre>

<p>Такой код выполнит 1 запрос, чтобы получить все книги из таблицы. А для получения имени автора будет сделан второй запрос внутри цикла. Таким образом этим кодом будет сделано N+1 запросов к базе (где N - это количество книг).</p>

<p>Чтобы уменьшить количество запросов, можно использовать "нетерпеливую" загрузку. Достаточно добавить метод "with", который добавит один запрос, но избавит от запроса в цикле</p>

<pre>
$books = App\Book::with('author')->get();

foreach ($books as $book) {
   echo $book->author->name;
}
</pre>

<h3>Что такое Laravel?</h3>

<p>Laravel – это PHP-фреймворк с открытым исходным кодом, созданный Тайлором Отвеллом в июне 2011 года. Он следует архитектурному шаблону MVC.</p>

<h3>Что такое контейнер IoC (инверсия контроля) или сервисный контейнер?</h3>

<p>Инверсия контроля, или сокращенно IoC, является техникой, которая позволяет инвертировать контроль выполнения в сравнении с классическим процедурным кодом. Наиболее известная форма IoC – это конечно Инъекция зависимости или DI. Контейнер IoC в Laravel – одна из наиболее часто используемых его возможностей, хотя и возможно менее понимаемая.</p>

<p>Вот простой пример использования Инъекции зависимости, чтобы получить инверсию контроля.</p>

<pre>
class JeepWrangler
{
public function __construct(Petrol $fuel)
{
$this->fuel = $fuel;
}

    public function refuel($litres)
    {
        return $litres * $this->fuel->getPrice();
    }
}

class Petrol
{
public function getPrice()
{
return 130.7;
}
}

$petrol = new Petrol;
$car = new JeepWrangler($petrol);

$cost = $car->refuel(60);
</pre>

<p>Используя инъекцию через конструктор, мы теперь делегировали создание инстанса Petrol вызывающему объекту, таким образом реализовав инверсию контроля. Наш класс JeepWrangler не должен знать, от куда он получит объект Petrol.</p>

<p>Но какое это все имеет отношение к Laravel? На самом деле очень большое. Laravel, если вы не знали, сам по себе является IoC контейнером. Контейнер это объект, который как вы уже могли догадаться, содержит другие объекты. Контейнер IoC в Laravel используется для хранения множества разных связей. Все что вы делаете в Laravel в какой-то степени взаимодействует с IoC контейнером. Это взаимодействие в большинстве случаев принимает форму получения связей.</p>

<p>Если вы откроете любой из существующих service provider’ов в Laravel, то скорее всего увидите в методе register что-то похоже на это (пример максимально упрощен).</p>

<pre>
$this->app['router'] = $this->app->share(function($app) {return new Router;});
</pre>

<p>Вот очень, очень простая привязка. Она состоит из имени связи (router) и способа её получения (замыкания). Когда мы пытаемся получить эту связь из контейнера, мы в ответ получим инстанс Router.</p>

<p>Laravel обычно группирует схожие имена связей, например session и session.store.</p>

<p>Чтобы получить связь, мы можем использовать метод контейнера make.</p>

<pre>
$router = $this->app->make('router');
</pre>

<p>Вот, что контейнер делает в своей самой базовой форме. Но, как и большинство вещей в Laravel, здесь внутри еще есть много всего, помимо привязок и разрешения классов.</p>

<h3>Что такое фасады Laravel?</h3>

<p>Фасады предоставляют «статический» интерфейс к классам, доступным в сервис-контейнере. Laravel поставляется со множеством фасадов, предоставляющих доступ почти ко всем возможностям Laravel. Фасады Laravel служат «статическими прокси» для классов в сервис-контейнере, обеспечивая преимущества краткого выразительного синтаксиса, и поддерживая большую тестируемость и гибкость, чем традиционные статические методы.</p>

<p>Все фасады Laravel определены в пространстве имён Illuminate\Support\Facades. Поэтому мы можем легко обратиться к фасаду таким образом:</p>

<pre>
use Illuminate\Support\Facades\Cache;

Route::get('/cache', function () {
return Cache::get('key');
});
</pre>

<p>Во многих примерах в документации по Laravel используются фасады для демонстрации различных возможностей фреймворка.</p>

<p>Фасады имеют много преимуществ. Они обеспечивают лаконичный, запоминающийся синтаксис, который позволяет вам использовать возможности Laravel, не запоминая длинные имена классов, которые должны внедряться или настраиваться вручную. Более того, благодаря уникальному использованию динамических методов PHP они легко тестируются.</p>

<h3>Что такое middleware Laravel?</h3>

<p>Посредники (англ. middleware) предоставляют удобный механизм для фильтрации HTTP-запросов вашего приложения. Например, в Laravel есть посредник для проверки аутентификации пользователя. Если пользователь не аутентифицирован, посредник перенаправит его на экран входа в систему. Если же пользователь аутентифицирован, посредник позволит запросу пройти далее в приложение.</p>

<p>Конечно, посредники нужны не только для авторизации. CORS-посредник может пригодиться для добавления особых заголовков ко всем ответам в вашем приложении. А посредник логов может зарегистрировать все входящие запросы.</p>

<p>В Laravel есть несколько стандартных посредников, включая посредники для аутентификации и CSRF-защиты. Все они расположены в каталоге app/Http/Middleware.</p>

<h3>Что такое CSRF? Почему он используется?</h3>

<p>Laravel позволяет легко защитить ваше приложение от атак с подделкой межсайтовых запросов (CSRF). Подделка межсайтовых запросов — тип атаки на сайты, при котором несанкционированные команды выполняются от имени аутентифицированного пользователя.</p>

<p>Laravel автоматически генерирует CSRF-“токен” для каждой активной пользовательской сессии в приложении. Этот токен используется для проверки того, что именно авторизованный пользователь делает запрос в приложение.</p>

<p>При определении каждой HTML-формы вы должны включать в неё скрытое поле CSRF-токена, чтобы посредник CSRF-защиты мог проверить запрос. Вы можете использовать вспомогательную функцию csrf_field() для генерирования поля токена:</p>

<pre>
<form method="POST" action="/profile">
  {{ csrf_field() }}
  ...
</form>
</pre>

<p>Посредник VerifyCsrfToken, входящий в группу посредников web, автоматически проверяет совпадение токена в данных запроса с токеном, хранящимся в сессии.</p>

<h3>Что такое Bootstrap?</h3>

<p>Bootstrap – это точка входа для запуска фреймворка Laravel.</p>

<h3>Что такое контракты laravel?</h3>

<p>Контракты в Laravel — это набор интерфейсов, которые описывают основной функционал, предоставляемый фреймворком. Например, контракт Illuminate\Contracts\Queue\Queue определяет методы, необходимые для организации очередей, в то время как контракт Illuminate\Contracts\Mail\Mailer определяет методы, необходимые для отправки электронной почты.</p>

<p>Каждый контракт имеет свою реализацию во фреймворке. Например, Laravel предоставляет реализацию Queue с различными драйверами и реализацию Mailer, использующую SwiftMailer.</p>

<p>Все контракты Laravel живут в своих собственных репозиториях GitHub. Эта ссылка ведёт на все доступные контракты, а также на один отдельный пакет, который может быть использован разработчиками пакетов.</p>

<h3>Какие каталоги нуждаются в разрешении на запись для установки и запуска Laravel?</h3>

<p>storage и bootsrap / cache</p>

<h3>Что такое Composer?</h3>

<p>Composer – это пакетный менеджер зависимостей, предназначенный для упрощения загрузки и установки сторонних php библиотек в проект. Например, с помощью него можно очень просто добавить в разрабатываемый проект php пакеты, а также развернуть другие проекты, которые распространяются вместе с файлом «composer.json».</p>

<p>«composer.json» – это текстовый файл, в котором в формате JSON описаны все сторонние пакеты от которых зависит данный проект.</p>

<p>источник: https://maxyc.ru/programming/laravel/laravel-top-10-questions/</p>

<h2>Что такое Contract'ы в экосистеме Laravel?</h2>

<p>«Контракты» Laravel – это набор интерфейсов, которые определяют основные службы фреймворка. Например, контракт Illuminate\Contracts\Queue\Queue определяет методы, необходимые для постановки заданий в очередь, а контракт Illuminate\Contracts\Mail\Mailer – для отправки электронной почты.</p>

<p>Каждый контракт имеет соответствующую реализацию, предусмотренную структурой. Например, Laravel предлагает реализацию очереди с множеством драйверов и реализацию почтовой программы, которая работает на SwiftMailer.</p>

<p>Все контракты Laravel находятся в их собственном репозитории GitHub. Это обеспечивает быстрый доступ к списку всех доступных контрактов, а также единый, отдельный пакет, который используется разработчиками пакетов, взаимодействующих со службами Laravel.</p>

<p>Фасады и глобальные помощники Laravel обеспечивают простой способ использования служб Laravel без объявления типов зависимости и извлечения их реализаций из контейнера служб. В большинстве случаев каждый фасад имеет эквивалентный контракт.</p>

<p>В отличие от фасадов, которые не требуют, чтобы они находились в конструкторе вашего класса, контракты позволяют вам определять явные зависимости для ваших классов. Некоторые разработчики предпочитают явно определять свои зависимости таким образом и поэтому предпочитают использовать контракты, в то время как другие разработчики пользуются удобством фасадов. В общем, большинство приложений могут без проблем использовать фасады во время разработки.</p>

<h2>Что такое Глобальные помощники в экосистеме Laravel?</h2>

<p>В дополнении к фасадам, Laravel предлагает множество глобальных «вспомогательных функций», которые упрощают взаимодействие с общими функциями Laravel. Вот некоторые из глобальных помощников, с которыми вы можете взаимодействовать – это view, response, url, config и т.д. Каждый помощник, предлагаемый Laravel, задокументирован с соответствующей функцией;</p>

<p>Например, вместо использования фасада Illuminate\Support\Facades\Response для генерации ответа JSON, мы можем просто использовать функцию response. Поскольку помощники доступны глобально, то вам не нужно импортировать какие-либо классы, чтобы использовать их:</p>

<pre>
use Illuminate\Support\Facades\Response;

Route::get('/users', function () {
   return Response::json([
      // ...
   ]);
});

Route::get('/users', function () {
   return response()->json([
      // ...
   ]);
});
</pre>

<h2>Жизненный цикл запроса</h2>

<h3>index.php</h3>

<p>Точкой входа для всех запросов к приложению Laravel является файл public/index.php. Все запросы направляются в этот файл конфигурацией вашего веб-сервера (Apache / Nginx). Файл index.php не содержит большого количества кода. Скорее, это отправная точка для загрузки остальной части фреймворка.</p>

<p>Файл index.php загружает автозагрузчик, созданный менеджером пакетов Composer, а затем извлекает экземпляр приложения Laravel из bootstrap/app.php. Первым действием, предпринимаемым самим Laravel, является создание экземпляра приложения / контейнера служб.</p>

<h3>HTTP-ядро и ядро консоли</h3>

<p>Затем входящий запрос отправляется либо HTTP-ядру, либо ядру консоли, в зависимости от типа запроса, поступающего в приложение. Эти два ядра служат центральным местом, через которое проходят все запросы. А пока давайте сосредоточимся на ядре HTTP, которое находится в app/Http/Kernel.php.</p>

<p>HTTP-ядро расширяет класс Illuminate\Foundation\Http\Kernel, который определяет массив загрузчиков (bootstrappers), запускающихся до выполнения запроса. Эти загрузчики настраивают обработку ошибок, логирование, определяют среду приложения и выполняют другие задачи, которые необходимо выполнить до фактической обработки запроса.</p>

<p>Ядро HTTP также определяет список HTTP-посредников, через которые должны пройти все запросы, прежде чем они будут обработаны приложением. Эти посредники обрабатывают чтение и запись HTTP-сессий, определяют, находится ли приложение в режиме обслуживания, проверяют токен CSRF и многое другое.</p>

<p>Сигнатура метода handle HTTP-ядра довольно проста: он получает запрос (Request) и возвращает ответ (Response). Думайте о ядре как о большом черном ящике, который представляет все ваше приложение. Дайте ему HTTP-запросы, и он вернет HTTP-ответы.</p>

<p>Одним из наиболее важных действий начальной загрузки ядра является загрузка поставщиков служб вашего приложения. Все поставщики служб приложения настраиваются в массиве providers конфигурационного файла config/app.php.</p>

<p>Laravel будет перебирать этот список поставщиков и создавать экземпляры каждого из них. После создания экземпляров поставщиков, будет вызван метод register всех поставщиков. Затем, как только все поставщики будут зарегистрированы, будет вызван метод boot каждого из них. Это сделано для того, чтобы те поставщики служб, которые имеют зависимости от других поставщиков, могли быть вызваны гарантированно после создания своих зависимостей, вызываемых в методе boot.</p>

<p>Поставщики служб несут ответственность за загрузку всевозможных компонентов инфраструктуры, таких как компоненты БД, очереди, валидации и маршрутизации. По сути, каждая основная функция Laravel загружается и настраивается поставщиком служб. Поскольку они запускают и настраивают так много функций, предлагаемых фреймворком, поставщики служб являются наиболее важным аспектом всего процесса начальной загрузки Laravel.</p>

<h3>Маршрутизация</h3>

<p>Одним из наиболее важных поставщиков служб в вашем приложении является App\Providers\RouteServiceProvider. Этот поставщик загружает файлы маршрутов, содержащиеся в каталоге routes приложения.</p>

<p>После того как приложение было загружено и все поставщики служб зарегистрированы, Request будет передан маршрутизатору для исполнения. Маршрутизатор отправит запрос на маршрут или контроллер, а также запустит посредник для конкретного маршрута.</p>

<p>Посредники обеспечивают удобный механизм фильтрации или интерпретации HTTP-запросов, поступающих в ваше приложение. Например, Laravel содержит посредника, который проверяет аутентификацию пользователя вашего приложения. Если пользователь не аутентифицирован, посредник перенаправит пользователя, например, на экран входа в систему. Однако, если пользователь аутентифицирован, посредник позволит запросу продолжить работу в приложении. Некоторые посредники назначаются всем маршрутам в приложении, например, определенным в свойстве $middleware вашего ядра HTTP, тогда как некоторые назначаются только для определенных маршрутов или групп маршрутов.</p>

<p>Если запрос проходит через всех посредников, назначенных определенному маршруту, то метод маршрута или контроллера будет выполнен, а ответ, возвращенный методом маршрута или контроллера, будет отправлен обратно через цепочку посредников маршрута.</p>

<h3>Окончание</h3>

<p>Когда метод маршрута или контроллера вернет ответ, тогда ответ отправится обратно через посредников маршрута, обеспечивая приложению возможность изменения или проверки исходящего ответа.</p>

<p>Наконец, как только ответ проходит через посредников, метод handle ядра HTTP возвращает объект ответа, а файл index.php вызывает метод send для возвращенного ответа. Метод send отправляет содержимое ответа в веб-браузер пользователя. Мы завершили наш путь через весь жизненный цикл запроса Laravel!</p>


<h2>Новое в PHP8.2.</h2>

<h3>Readonly-классы</h3>

<p>Начиная с PHP 8.2.0, класс может быть помечен модификатором readonly. 
Пометка класса как readonly добавит модификатор readonly к каждому объявленному свойству и предотвратит создание 
динамических свойств. Более того, невозможно добавить их поддержку с помощью атрибута AllowDynamicProperties. 
Попытка это сделать приведёт к ошибке компиляции.</p>

<h3>Типы в виде дизъюнктивной нормальной формы</h3>

<pre>
class Foo {
    public function bar((A&B)|null $entity) {
        return $entity;
    }
}
</pre>

<h3>Самостоятельные типы null, false и true</h3>

<pre>
class Falsy
{
    public function alwaysFalse(): false { /* ... */ *}

    public function alwaysTrue(): true { /* ... */ *}

    public function alwaysNull(): null { /* ... */ *}
}
</pre>

<h3>Новый модуль "Random"</h3>

<p>Модуль "random" предлагает новый объектно-ориентированный API для генерации случайных чисел. Вместо использования глобального генератора случайных чисел (ГСЧ) на базе алгоритма вихря Мерсенна, в объектно-ориентированном API доступно несколько ГСЧ, представленных отдельными классами (как реализации интерфейса Engine), которые хранят внутреннее состояние, позволяя создавать несколько независимых последовательностей случайных чисел.</p>

<p>Класс \Random\Randomizer представляет высокоуровневый интерфейс по использованию движков для генерации случайного целого числа, перемешивания массива или строки, выбора случайных ключей массива и многое другое.</p>

<h3>Константы в трейтах</h3>

<p>Нельзя получить доступ к константе через имя трейта, но можно через класс, который использует этот трейт.</p>

<pre>
trait Foo
{
    public const CONSTANT = 1;
}

class Bar
{
    use Foo;
}

var_dump(Bar::CONSTANT); // 1
var_dump(Foo::CONSTANT); // Error
</pre>

<h3>Получение свойств перечислений в константных выражениях</h3>

<pre>
enum A: string 
{
    case B = 'B';
    
    const C = [self::B->value => self::B];
}
</pre>

<h3>Динамические свойства объявлены устаревшими</h3>

<pre>
class User
{
    public $name;
}

$user = new User();
$user->last_name = 'Doe'; // Deprecated notice

$user = new stdClass();
$user->last_name = 'Doe'; // Still allowed
</pre>

<p>Динамические свойства устарели в PHP 8.2 и будут выдавать ошибку ErrorException в PHP 9.0. Если вы не знаете, что такое динамические свойства, то это свойства, которые не присутствуют в объекте, но тем не менее присваиваются или запрашиваются:</p>

<p>Чтобы помочь избежать ошибок и опечаток, больше не рекомендуется определять динамические свойства, 
только если сам класс явно не разрешит это при помощи атрибута #[\AllowDynamicProperties]. 
В экземплярах stdClass по-прежнему можно использовать динамические свойства.</p>

<p>Это изменение не влияет на использование магических методов <strong>get/</strong>set.</p>

<h3>Новые классы, интерфейсы и функции</h3>

<ul>
<li>Новая функция mysqli_execute_query и метод mysqli::execute_query.</li>
<li>Новые атрибуты #[\AllowDynamicProperties] и #[\SensitiveParameter].</li>
<li>Новые методы ZipArchive::getStreamIndex, ZipArchive::getStreamName и ZipArchive::clearError.</li>
<li>Новые методы ReflectionFunction::isAnonymous и ReflectionMethod::hasPrototype.</li>
<li>Новые функции curl_upkeep, memory_reset_peak_usage, ini_parse_quantity, libxml_get_external_entity_loader, sodium_crypto_stream_xchacha20_xor_ic, openssl_cipher_key_length.</li>
</ul>

<h3>Устаревшая функциональность и изменения в обратной совместимости</h3>

<ul>
<li>Интерполяции строк вида ${} следует избегать.</li>
<li>Не рекомендуется использовать функции utf8_encode и utf8_decode.</li>
<li>У методов DateTime::createFromImmutable и DateTimeImmutable::createFromMutable задан предварительный тип возвращаемого значения static.</li>
<li>Модули ODBC и PDO_ODBC экранирует имя пользователя и пароль.</li>
<li>При работе функции strtolower и strtoupper теперь не учитывают локаль.</li>
<li>Методы SplFileObject::getCsvControl, SplFileObject::fflush, SplFileObject::ftell, SplFileObject::fgetc и SplFileObject::fpassthru усиливают свою сигнатуру.</li>
<li>У метода SplFileObject::hasChildren предварительный тип возвращаемого значения задан как false.</li>
<li>У метода SplFileObject::getChildren предварительный тип возвращаемого значения задан как null.</li>
<li>Внутренний метод SplFileInfo::_bad_state_ex объявлен устаревшим.</li>
</ul>

<h3>ksort(..., SORT_REGULAR) изменения порядка сортировки</h3>

<p>До версии PHP 8.2 ksort буквенные ключи помещались перед числовыми</p>

<h3>Устаревание utf8_encode() и utf8_decode()</h3>

<p>В PHP 8.2 использование любой функции из utf8_encode() или utf8_decode() вызовет следующие уведомления об устаревании</p>

<h3>Нечувствительный к локали strtolower() и strtoupper()</h3>

<p>И strtolower() и strtoupper() больше не зависят от региональных настроек. Вы можете использовать mb_strtolower(), если хотите локализованное преобразование регистра.</p>


<h2>Новое в PHP8.1</h2>

<h3>Перечисления</h3>

<p>Введение Enum избавляет от необходимости использовать костыльные решения (например, создавать перечисления из классов) и подтягивать сторонние пакеты. Обновление действительно ждали — об этом свидетельствует популярность руководств по реализации перечислений в PHP и библиотек Enum и PHP-enum.</p>

<p>Перечисление в виде типа дает контроль над кодом, помогает соблюдать принцип DRY и снизить сложность восприятия кода.</p>

<p>Предположим, что приложение должно учитывать времена года. Хорошо, если они реализованы в виде строк (например, $season = 'winter'), но если речь идет о числах в виде $season = 0, код очень скоро начинает вызывать вопросы. Строки и числа, используемые для перечислений, тяжело валидировать. Для каждой функции, в которую приходит строка или число $enumVar, нужно проверять, что все работает хорошо. С Enum валидация становится проще:</p>

<pre>
enum Status
{
case Draft;
case Published;
case Archived;
}
function acceptStatus(Status $status) {...}
</pre>

<h3>Readonly-свойства</h3>

<p>Фича полезна при реализации объектов типа value и data transfer. Она предназначена для работы с вычисляемыми значениями и позволяет не беспокоиться, что значение будет перезаписано.</p>

<p>При организации классов бывают случаи, когда нужна «вычисляемая константа». В предыдущих версиях разработчик создавал функцию, которая вызывается каждый раз, когда нужно получить значение константы, и забивает стек вызовов. Альтернативное решение — использование статистических переменных, которые повышают вероятность ошибки из-за своей изменчивости. Readonly поможет однозначно понять, что переменную присвоили, и работать с ее значением.</p>

<pre>
class BlogData
{
    public readonly Status $status;

    public function __construct(Status $status)
    {
        $this->status = $status;
    }
}
</pre>

<h3>Файберы</h3>

<p>Примитивы, которые позволяют синхронно держать в памяти несколько процессов и запускать каждый из них при необходимости. Вероятно, главная задача нововведения — сделать «асинхронные» участки кода быстрее и упростить их поддержку.</p>

<pre>
$response = $httpClient->request('https://example.com/');
print json_decode($response->getBody()->buffer())['code'];
</pre>

<p>Файбер вряд ли будет широко использоваться при разработке ПО на высоких уровнях. Но на более низких (фреймворки Laravel, Symfony, Yii2, etc; пакеты для асинхронной работы ReactPHP и Amp) они точно будут полезны. В частности, для повышения производительности, переписывания части блоков кода с yield и, возможно, для переписывания реализаций корутин на основе генератора.</p>

<h3>Новые функции</h3>

<ul>
<li>Array_is_list — функция помогает проверить, что ключи элементов массива это числа идущие по порядку от 0.</li>
<li>fsync и fdatasync — функции дополнительной проверки при редактировании файла, которые синхронизируют изменения. Интересно, что на Windows разницы между функциями нет: fdatasync в данном случае — ссылка на fsync.</li>
<li>Serializable становится deprecated — после перехода на новую версию придется удалить из кода implements Serializable и поменять все функции serialize()/unserialize() на <strong>serialize()/</strong>unserialize()</li>
<li>resource становится deprecated — если resource использовался в коде, при переходе на новую версию придется менять все вхождения.</li>
</ul>

<h3>Другие обновления</h3>

<p>Оставшиеся обновления можно поделить на два типа:
Делают код чище. К этой категории относятся явное восьмеричное числовое обозначение, тип возвращаемого значения never, callback-функции как объекты первого типа, расширенная инициализация объектов и пересечение типов.
Дают больше контроля в коде. Здесь речь идет о финальных константах класса.</p>

<p>Отдельно стоит отметить прирост производительности в новой версии: на 23% для демо-приложения на фреймворке Symfony и на 3,5% для WordPress по сравнению с PHP 8. Важно понимать, что производительность часто индивидуальна и зависит от конкретного приложения.</p>


<h2>Новое в PHP8.0.</h2>

<h3>Вместо docblock — атрибуты.</h3>

<pre>
use \Support\Attributes\ListensTo;

class ProductSubscriber
{
<<ListensTo(ProductCreated::class)>>
public function onProductCreated(ProductCreated $event) { /* … */ }

    <<ListensTo(ProductDeleted::class)>>
    public function onProductDeleted(ProductDeleted $event) { /* … */ }
}
</pre>

<h3>Объединение типов аргументов методов</h3>

<pre>
public function foo(Foo|Bar $input): int|float;
public function bar(mixed $input): mixed;

</pre>

<p>Объединение типов позволяет указывать сразу несколько типов. Также есть новый mixed тип, который представляет несколько типов одновременно.</p>

<h3>Можно указать static в return type.</h3>

<pre>
interface Foo
{
public function bar(): static;
}
</pre>

<h3>Встроенный JIT-компилятор.</h3>

<pre>
[JIT]
opcache.jit=5
</pre>

<p>Что такое JIT?</p>

<p>«JIT» расшифровывается как «just in time» — «в нужный момент». Вы, вероятно, знаете, что PHP является интерпретируемым языком: он не скомпилирован как программа на C, Java или Rust. Вместо этого он переводится в машинный код — то, что понимает процессор — во время выполнения.</p>

<p>«JIT» — это метод, который компилирует части кода во время выполнения так, что вместо этого можно использовать скомпилированную версию.</p>

<p>Думайте об этом как о «кэшированной версии» интерпретируемого кода, сгенерированного во время выполнения.</p>

<h3>throw может быть использован в выражениях.</h3>

<pre>
$triggerError = fn() => throw new MyError();

$foo = $bar['offset'] ?? throw new OffsetDoesNotExist('offset');
</pre>

<h3>Можно не указывать переменную исключения, если она вам не нужна.</h3>

<pre>
try {
    // Something goes wrong
} catch (MySpecialException) {
    Log::error("Something went wrong");
}
</pre>

<h3>В конце списка параметров можно указать запятую.</h3>

<pre>
public function(
    string $parameterA,
    int $parameterB,
    Foo $objectfoo,
) {
    // …
}
</pre>

<h3>Новые строковые функции</h3>

<pre>
str_contains('string with lots of words', 'words');

str_starts_with('haystack', 'hay');

str_ends_with('haystack', 'stack');
</pre>

<h3>Новый Stringable interface, который автоматически добавляется в классы, которые реализуют метод __toString ().</h3>

<pre>
function bar(Stringable $stringable) { /* … */ }
</pre>

<h3>Вызов ::class сразу из объекта.</h3>

<pre>
$object::class
</pre>


<h2>PHP 7.4. Что нового</h2>

<h3>Свойства класса теперь поддерживают объявления типов.</h3>

<pre>
class User {
public int $id;
public string $name;
}
</pre>

<h3>Стрелочные функции</h3>

<p>Стрелочные функции - это сокращённая запись для определения функций с неявной привязкой родительской области видимости по значению.</p>

<pre>
$factor = 10;
$nums = array_map(fn($n) => $n * $factor, [1, 2, 3, 4]);
// $nums = array(10, 20, 30, 40);
</pre>

<p>Стрелочные функции появились в PHP 7.4, как более лаконичный синтаксис для анонимных функций.</p>

<p>И анонимные, и стрелочные функции реализованы с использованием класса Closure.</p>

<p>Основной вид записи стрелочных функций: fn (argument_list) => expr.</p>

<p>Стрелочные функции поддерживают те же возможности, что и анонимные функции, за исключением того, что использование переменных из родительской области всегда выполняется автоматически.</p>

<p>Когда переменная, используемая в выражении, определена в родительской области, она будет неявно захвачена по значению. В следующем примере функции $fn1 и $fn2 ведут себя одинаково.</p>

<p>Пример #1 Стрелочные функции захватывают переменные по значению автоматически</p>

<pre>
$y = 1;

$fn1 = fn($x) => $x + $y;
// эквивалентно использованию $y по значению:
$fn2 = function ($x) use ($y) {
return $x + $y;
};

var_export($fn1(3));

4
</pre>

<p>Это также работает во вложенных стрелочных функциях:</p>

<p>Пример #2 Стрелочные функции захватывают переменные по значению автоматически, даже когда они вложены</p>

<pre>
$z = 1;
$fn = fn($x) => fn($y) => $x * $y + $z;
// Выведет 51
var_export($fn(5)(10));
</pre>

<p>Подобно анонимным функциям, синтаксис стрелочных функций допускает произвольные сигнатуры функций, включая типы параметров и возвращаемых значений, значения по умолчанию, переменные, а также передачу и возврат по ссылке. Ниже приведены корректные примеры стрелочных функций:</p>

<pre>
fn(array $x) => $x;
static fn(): int => $x;
fn($x = 42) => $x;
fn(&$x) => $x;
fn&($x) => $x;
fn($x, ...$rest) => $rest;
</pre>

<p>Стрелочные функции используют привязку переменных по значению. Это примерно эквивалентно выполнению use($x) для каждой переменной $x, используемой внутри стрелочной функции. Привязка по значению означает, что невозможно изменить какие-либо значения из внешней области. Вместо этого можно использовать анонимные функции для привязок по ссылкам.</p>

<pre>
$x = 1;
$fn = fn() => $x++; // Ничего не изменит
$fn();
var_export($x);  // Выведет 1
</pre>

<p>Анонимные функции, также известные как замыкания (closures), позволяют создавать функции, не имеющие определённых имён. Они наиболее полезны в качестве значений callable-параметров, но также могут иметь и множество других применений.</p>

<p>Анонимные функции реализуются с использованием класса Closure.</p>

<h3>Ограниченная ковариация возвращаемого типа и контравариантность типа аргумента ¶</h3>

<p>Следующий код теперь будет работать:</p>

<pre>
class A {}
class B extends A {}

class Producer {
public function method(): A {}
}
class ChildProducer extends Producer {
public function method(): B {}
}
</pre>

<p>Полная поддержка вариантности доступна только при использовании автозагрузки. Внутри одного файла могут быть только нециклические ссылки, поскольку все классы должны быть определены, перед тем как на них ссылаться.</p>

<h3>Присваивающий оператор объединения с null</h3>

<pre>
$array['key'] ??= computeDefault();
// примерно то же самое
if (!isset($array['key'])) {
$array['key'] = computeDefault();
}
</pre>

<h3>Распаковка внутри массивов</h3>

<pre>
$parts = ['apple', 'pear'];
$fruits = ['banana', 'orange', ...$parts, 'watermelon'];
// ['banana', 'orange', 'apple', 'pear', 'watermelon'];

</pre>

<h3>Разделитель в числовых литералах</h3>

<p>Теперь в числовых литералах между знаками могут быть символы подчёркивания.</p>

<pre>
6.674_083e-11; // число с плавающей точкой
299_792_458;   // десятичное число
0xCAFE_F00D;   // шестнадцатеричное число
0b0101_1111;   // двоичное число
</pre>

<h3>Слабые ссылки</h3>

<p>Слабые ссылки позволяют программисту сохранить ссылку на объект, которая не помешает сборщику мусора удалить этот объект.</p>

<p>Класс WeakReference предоставляет способ доступа к объекту, не влияя при этом на количество ссылок на него, таким образом сборщик мусора сможет освободить этот объект.
Объект класса WeakReference не может быть сериализован.</p>

<pre>
$obj = new stdClass;
$weakref = WeakReference::create($obj);
var_dump($weakref->get());
unset($obj);
var_dump($weakref->get());
</pre>

<h3>Обработка исключений из метода __toString()</h3>

<p>Выбрасывание исключений из метода __toString() теперь разрешено. Ранее это приводило к фатальной ошибке. Существующие отлавливаемые фатальные ошибки при преобразовании объекта в строку будут доступны в виде исключений класса Error.</p>

<h3>CURL</h3>

<p>Помимо обычных имён файлов, класс CURLFile теперь поддерживает потоковые обёртки, если модуль был собран с версией libcurl >= 7.56.0.</p>

<h3>Хеширование</h3>

<p>Добавлен хеш crc32c, использующий полином Кастаноли. Эта реализация алгоритма CRC32 используется системами хранения, такими как iSCSI, SCTP, Btrfs и ext4.</p>

<h3>Многобайтовые строки</h3>

<p>Добавлена функция mb_str_split(), которая выполняет, то же, что и str_split(), но работает с кодовыми точками, а не с байтами.</p>

<h3>OPcache</h3>

<p>Добавлена поддержка предварительной загрузки кода.</p>

<h3>PDO</h3>

<p>Имя пользователя и пароль теперь можно указать как часть DSN для драйверов mysql, mssql, sybase, dblib, firebird и oci. Ранее поддержка этого была только для драйвера pgsql. Если имя пользователя/пароль указаны и в конструкторе и в DSN, то конструктор будет иметь приоритет.</p>

<p>Также теперь можно экранировать вопросительные знаки в SQL-запросах, чтобы они не воспринимались как именованные параметры. Использование ?? отправит один знак вопроса в базу данных, и, например, в случае использования PostgreSQL, будет использован оператор проверки существования ключа в JSON (?).</p>

<h3>strip_tags() с массивом имён тегов</h3>

<p>Функция strip_tags() теперь также принимает массив разрешённых тегов: вместо strip_tags($str, '<a><p>') теперь можно написать strip_tags($str, ['a', 'p']).</p>

<h3>Пользовательская сериализация объектов</h3>

<p>Добавлен новый механизм сериализации пользовательских объектов, использующий два новых магических метода: __serialize и __unserialize.</p>

<pre>
// Возвращает массив, содержащий все необходимое состояние объекта.
public function __serialize(): array;

// Восстанавливает состояние объекта из указанного массива данных.
public function __unserialize(array $data): void;


</pre>

<p>Новый механизм сериализации заменяет интерфейс Serializable, который в будущем будет объявлен устаревшим.</p>

<h3>Функции слияния массивов без аргументов</h3>

<p>Функции array_merge() и array_merge_recursive() теперь могут вызываться без каких-либо аргументов, и тогда они возвратят пустой массив. Это полезно в сочетании с оператором расширения, например, array_merge(...$arrays).</p>

<h3>Функция proc_open()</h3>

<p>proc_open() теперь принимает массив вместо строки для выполнения команды. В этом случае процесс будет открыт напрямую (без командной оболочки), а PHP экранирует любой необходимый аргумент.</p>

<pre>
proc_open(['php', '-r', 'echo "Привет, мир\n";'], $descriptors, $pipes);
</pre>

<p>Функция proc_open() теперь поддерживает дескрипторы redirect и null.</p>

<pre>
// То же самое, что и 2>&1 в командной оболочке
proc_open($cmd, [1 => ['pipe', 'w'], 2 => ['redirect', 1]], $pipes);
// То же самое, что и 2>/dev/null или 2>nul в командной оболочке
proc_open($cmd, [1 => ['pipe', 'w'], 2 => ['null']], $pipes);
</pre>


<h2>PHP 7.3. Что нового</h2>

<h3>Смягчение требований к синтаксису Heredoc и Nowdoc</h3>

<p>Heredoc и Nowdoc требовали ставить закрывающий идентификатор первым в новой строке.</p>

<p>Пример:</p>

<pre>
$foo = &lt;&lt;&lt;IDENTIFIER
the crazy dog jumps over the lazy fox  
"foo" bar;  
IDENTIFIER
</pre>

<p>Здесь закрывающий IDENTIFIER должен быть первым символом на новой линии чтобы это работало. Кроме того, не должно было быть никаких других символов после закрывающего идентификатора (кроме ;, который является необязательным).</p>

<p>RFC для PHP 7.3 предлагает убрать подобные требования для улучшения читабельности кода. Прежде всего чтобы добавить отступы при использовании heredoc/nowdoc идентификаторов.</p>

<p>Полный список изменений в heredoc/nowdoc синтаксисе:</p>

<ul>
<li>Закрывающий идентификатор необязательно должен быть первым символом в строке.</li>
<li>Закрывающий идентификатор имеет отступ пробелами или табами.</li>
<li>Отступ (пробелы или табы) не должен быть смешанным. Если вы это сделаете, то получите Parse error: Invalid indentation - tabs and spaces cannot be mixed in .. on line ...</li>
<li>Точное количество пробелов/табов, используемых перед закрывающим идентефикатором будут удалены из каждой строки heredoc/nowdoc выражения.</li>
<li>Если число отступающих символов, используемых перед закрывающим идентефикатором, больше чем в любой из строк выражения, вы получите Parse error: Invalid body indentation level (expecting an indentation level of at least ..) in .. on line ..</li>
<li>несколько выражений после закрывающего идентификатора будут работать без ошибок</li>
</ul>

<p>Пока вы не используете набор идентичных heredox/nowdoc идентификаторам символов в качестве начала строки, вы на коне.</p>

<pre>
$foo = &lt;&lt;&lt;HELLO  
HELLO_WORLD <-- это не будет приниматься за окончание строкового литерала
HELLOWORLD  <-- и это не будет
HELLO WORLD <-- а это будет
HELLO;
</pre>

<h3>Поддержка конечных запятых в вызовах функций и методов</h3>

<p>Это простое изменение, которое разрешает использование конечных запятых в вызовах функций и методах. Это не влияет на декларирование.</p>

<p>Например, следующий синтаксис станет возможным:</p>

<pre>

// функция
foo('bar', 'baz',); // Обратите внимание на последнюю запятую после  после 'baz'

</pre>

<p>В до-PHP-7.3 версиях фрагмент выше выбрасывает ошибку PHP Parse error:  syntax error, unexpected ')' in .. on line ...</p>

<p>Вы не можете использовать более одной запятой в конце или использовать запятые для пропуска аргументов. В основном это изменение для функции с вариативными параметрами. Также с новыми правками синтаксис массива будет выглядеть более последовательным.</p>

<p>Обратите внимание, что Вы не можете использовать эту возможность в объявлениях функций/методов; это неправильно:</p>

<pre>
function foo($bar, $baz, ) { // nah, you can't do this.  
}
</pre>

<h3>Ссылки в list()</h3>

<p>Функция list() полезна для быстрого присвоения значений переременным из массива. До версии PHP 7.3 не было возможным указать переменную по ссылке. До PHP 7.3 следующий фрагмент приводил к фатальной ошибке:</p>

<pre>
$arr = ['apple', 'orange'];  
list($a, &$b) = $arr;  
$b = 'banana';  
echo $arr[1];  
// Fatal error: [] and list() assignments cannot be by reference in .. on line ..

</pre>

<p>Ссылкаться на non-referencable переменные нельзя: list($a, &amp;$b) = [12, 14]; выдаст Fatal error: Cannot assign reference to non referencable value in .. on line ...</p>

<h3>Функция image2wbmp() объявлена устаревшей</h3>

<p>image2wbmp() функция из расширения GD используется для вывода изображения в формате WBMP (Wireless Bitmap). В PHP 7.3 она объявлена устаревшей в пользу функции imagewbmp().</p>

<p>Если вы используете image2wbmp(), то просто замените название функции на imagewbmp и все будет хорошо!</p>

<h3>Флаги FILTER_FLAG_SCHEME_REQUIRED и FILTER_FLAG_HOST_REQUIRED при использовании FILTER_VALIDATE_URL объявлены устаревшими</h3>

<p>TL;DR</p>

<h3>Регистро-независимые константы объявлены устаревшими</h3>

<p>Функция define() позволяет объявить константу в регистро-независимом режиме. Вы должны явно объявить константу с учетом регистра, передав третьим параметром функции true. Это не поведение по-умолчанию и наверняка не согласуется с возможностью объявлять константы через ключевое слово const.</p>

<pre>
define('Foo', 'Bar', true);
</pre>

<p>Приведенный выше код будет выбрасывать уведомление об устаревании: Deprecated: define(): Declaration of case-insensitive constants is deprecated in ...</p>

<h3>Опциональный выброс исключений при ошибках в функциях json_encode и json_decode</h3>

<p>Все эти годы json_encode() и json_decode() молчали об ошибках в PHP-переменных или json-строках, что приводило к забагованному коду.</p>

<pre>
try {  
json_decode("{", false, 512, JSON_THROW_ON_ERROR);  
}  
catch (\JsonException $exception) {  
echo $exception->getMessage(); // выводит "Syntax error"  
}

</pre>

<p>Новый \JsonException является наследником от \Exception, а также константа JSON_THROW_ON_ERROR и сам JsonException находятся в глобальном пространстве имен.</p>

<h3>Добавление функции is_countable()</h3>

<p>В PHP 7.2 достаточно много устаревших и забагованных функций. Если вы в PHP 7.2. вызываете count() с использованием не-countable переменной, то PHP выведет предупреждение об этом. В общих правках было предложение проверять получаемую перменную на countable до ее использования в count().</p>

<p>countable-переменной является массив или объект реализующий \Countable интерфейс. Так как при проверке будет использоваться много шаблонного кода, в PHP 7.3 появилась новая функция is_countable(), проверяющая переменную на… ну… возможность использования с count().</p>

<h3>Добавление функций array_key_first() и array_key_last()</h3>

<p>В PHP существует 75 различных функций для работы с массивами, но до сих пор не было простого способа получить первый и последний ключи массива без изменения указателя массива или перебора всех ключей (через array_keys()) и затем получения первого/последнего значения.</p>

<p>Появились две новые функции, array_key_first() и array_key_last() позволяющие это делать.</p>

<h3>Миграция с PCRE на PCRE2</h3>

<p>PHP использует Perl Compatible Regular Expressions или коротко PCRE в библитеке для работы с регулярными выражениями. С версии PHP 7.2 используется 8.x версия легаси-библиотеки PCRE, а в PHP 7.3 уже будет использоваться PCRE2. Обратите внимание, что PCRE2 считается новой библитекой, хотя в значительной степени совместима с PCRE (8.x).</p>

<p>Новая библитека более агрессивна в валидации паттернов и может привести к ошибкам в существующем коде. Следующий фрагмент будет невалидным с PHP 7.3:</p>

<pre>
preg_match('/[\w-.]+/', '');
</pre>

<p>PHP выбросит предупреждение Warning: preg_match(): Compilation failed: invalid range in character class at offset 3.
Проблема с шаблоном: чтобы это работало дефис должен быть перемещен в конец или экранирован.</p>

<pre>
preg_match('/[\w\-.]+/', '');

</pre>


<h2>Что нового в PHP 7.2</h2>

<h3>Оптимизация</h3>

<p>В Opcache добавлена глобальная оптимизация на основе анализа потока данных с использованием SSA (Static single assignment form): Sparse Conditional Constant Propagation (SCCP), удаление мертвого кода (Dead Code Elimination — DCE) и удаление неиспользуемых локальных переменных.</p>

<p>Оптимизирована работа встроенной функции in_array() с помощью поиска хеша в перевернутом массиве.</p>

<h3>Добавлена возможность загружать расширения по имени</h3>

<p>Раньше extension= и zend_extension= в файле php.ini содержали пути до файла расширения.
Но, к сожалению, имя файла зависело от платформы. Например, в unix-подобных системах оно строилось как <extension-name>.<suffix>, где suffix это .so на всех системах кроме HP-UX, где он sl. В Windows имя файла формируется как php_<extension-name>.dll. Всё это порождало много ошибок.</p>

<p>Теперь вы можете писать:</p>

<pre>
extension=bz2
zend_extension=xdebug
</pre>

<p>И нужные расширения будут подгружены в зависимости от ОС.</p>

<p>Этот механизм будет работать при установке extension и zend_extension в ini-файле, а также как аргумент для функции dl().</p>

<p>Но абсолютные пути по-прежнему необходимо будет указывать при флаге -z в CLI-режиме, а также при указании абсолютного пути. Следующий пример работать не будет:</p>

<p>extension=/path/to/extensions/bz2</p>

<h3>Добавлена возможность перегружать абстрактные методы</h3>

<pre>
abstract class A           { abstract function bar(stdClass $x);  }
abstract class B extends A { abstract function bar($x): stdClass; }
class C extends B          { function bar($x): stdClass{} }
</pre>

<p>До PHP 7.2 выдавалась ошибка вида:</p>

<pre>
Fatal error: Can't inherit abstract function A::bar() (previously declared abstract in B)
</pre>

<h3>Запрещено number_format() возвращать -0</h3>

<p>Вызов number_format(-0.00)возвращал string(1) “0”, однако number_format(-0.01) возвращал string(2) “-0”. Сейчас же будет возвращен 0 без знака.</p>

<h3>Добавлена возможность конвертировать нумерованные ключи при приведении типов object/array</h3>

<p>Предыстория:</p>

<p>В PHP есть два типа данных, которые содержат ключ/значение. Первый — это массивы, которые могут содержать ключи в виде строк или чисел. При этом если строка удовлетворяет правилу /^(0|(-?[1-9][0-9]*))$/ и она достаточно маленькая PHP_INT_MIN ≤ n ≤ PHP_INT_MAX, то она конвертируется в числовой ключ.</p>

<p>Второй тип — это объекты, в которых недопустимы числовые ключи, и ключи конвертируются в строки.</p>

<p>При этом в Zend Engine они представлены в виде одной структуры HashTable.</p>

<p>Теперь это исправлено.</p>

<p>Давайте посмотрим на пару примеров:</p>

<pre>
$obj = new stdClass;

$obj->{'0'} = 1;
$obj->{'1'} = 2;
$obj->{'2'} = 3;
$arr = (array) $obj;

var_dump($arr); // Видим, что массив содержит ключи/значения
var_dump($arr[1]); // Не можем обратиться по ключу. В PHP 7.2 это исправлено.
</pre>

<pre>
$arr = [0 => 1, 1 => 2, 2 => 3];
$obj = (object)$arr;

var_dump($obj); // Видим, что объект содержит ключи/значения
var_dump($obj->{'0'}); // Не можем обратиться по ключу. В PHP 7.2 это исправлено.
</pre>

<h3>Запрещено передавать null в качестве параметра для get_class()</h3>

<p>Когда null передается как параметр get_class() внутри контекста класса, поведение функции может быть весьма неожиданным:</p>

<pre>
class Foo
{
function bar($repository)
{
$result = $repository->find(100);
return get_class($result);
}
}
</pre>

<p>Если $result содержит действительный объект, возвращенный из репозитория, результатом функции будет имя класса этого объекта.</p>

<p>Если $result содержит null, выход будет иметь контекст класса, из которого вызывается get_class(), в этом случае Foo.</p>

<p>Эта особенность нарушает принцип наименьшего удивления: «если необходимая функция имеет высокий коэффициент удивления, может потребоваться перепроектирование этой функции».
Теперь будет выдаваться предупреждение:
Warning: get_class() expects parameter 1 to be object, null given in %s on line %d
Если вы хотите сохранить старое поведение, придётся переписать код:</p>

<pre>
// Было:
$x = get_class($some_value_that_may_be_null);

// Стало:
if ($some_value_that_may_be_null === null) {
$x = get_class();
} else {
$x = get_class($some_value_that_may_be_null);
}
</pre>

<h3>Вызов Count с параметром, который нельзя посчитать</h3>

<p>Теперь вызов count() с параметром, который является скалярным, null или объектом, который не реализовал интерфейс Countable, будет выдавать Warning.</p>

<h3>Возможность расширения типа параметра</h3>

<p>Одно из самых горячо обсуждаемых изменений — возможность не указывать тип параметра в наследнике. Таким образом наследник сможет принять параметр любого типа.</p>

<pre>
class ArrayClass {
public function foo(array $foo) { /* ... */ }
}

class EverythingClass extends ArrayClass {
public function foo($foo) { /* ... */ }
}
</pre>

<p>До PHP 7.2 возвращалась ошибка:</p>

<pre>
Warning: Declaration of EverythingClass::foo($foo) should be compatible with ArrayClass::foo(array $foo) in %s on line 18
</pre>

<h3>Добавлена возможность указывать запятую в конце группированных неймспейсов</h3>

<pre>
// Раньше это работало только для массивов
$array = [1, 2, 3,];

// Теперь и для группировки неймспейсов
use Foo\Bar\{ Foo, Bar, Baz, };
</pre>

<p>Планировалось добавить такую возможность и для других списков, но на стадии голосования они были отменены и будут по-прежнему возвращать Parse error</p>

<h3>Реализовано семейство функций socket_getaddrinfo</h3>

<p>Теперь из PHP будет доступна информация из getaddrinfo(), реализованная на C.
TL;DR</p>

<h3>Улучшены TLS-константы</h3>

<p>TL;DR</p>

<h3>Object typehint</h3>

<p>Добавлен новый тип для хинта: object</p>

<pre>
function acceptsObject(object $obj) {
// ...
}

acceptsObject(json_decode('{}'));
acceptsObject(new \MyObject());
acceptsObject("Будет ошибка");

function correctFunction() : object {
$obj = json_decode('{}');
return $obj;
}

// Будет ошибка
function errorFunction() : object {
return [];
}
</pre>

<h3>LDAP EXOP</h3>

<p>Добавлены функции для использования расширенных операций LDAP в php-ldap.</p>

<p>TL;DR</p>

<h3>В ядро PHP добавлена Libsodium</h3>

<p>Libsodium — современная криптографическая библиотека, которая предлагает аутентифицированное шифрование, высокоскоростную криптографию с эллиптическими кривыми и многое другое. В отличие от других криптографических стандартов (которые являются набором криптографических примитивов, например, WebCrypto), libsodium включает в себя тщательно подобранные алгоритмы, реализованные экспертами по безопасности. Это поможет избежать уязвимостей в сторонних каналах.</p>

<h3>Добавлен алгоритм Argon2 в хешировании пароля</h3>

<p>Argon2 — это современный простой алгоритм, направленный на высокую скорость заполнения памяти и эффективное использование нескольких вычислительных блоков.</p>

<h3>HashContext as Object</h3>

<p>Начиная с PHP5 предпочтительной структурой для хранения внутренних данных были объекты. По какой-то причине в расширении Hash для этого использовались ресурсы. Данный RFC пытается исправить недоразумение, переведя расширение Hash на хранение внутренних данных в виде объектов.</p>

<p>Примеры использования ресурса в качестве внутреннего представления:</p>

<pre>
resource hash_copy ( resource $context )
resource hash_init ( string $algo [, int $options = 0 [, string $key = NULL ]] )

</pre>

<p>Внутреннее представление преобразуется из ресурса в объект. Существующий код должен продолжить работать, если он не использует явных проверок is_resource(), эти проверки могут быть легко заменены на is_resource | is_object.</p>

<h3>Добавлен отладчик PDO Prepared statements</h3>

<pre>
$db = new PDO(...);

$stmt = $db->query('SELECT 1');
var_dump($stmt->activeQueryString()); // => string(8) "SELECT 1"

$stmt = $db->prepare('SELECT :string');
$stmt->bindValue(':string', 'foo');

// возвращает необработанную строку до выполнения
var_dump($stmt->activeQueryString()); // => string(14) "SELECT :string"

// возвращает обработанную строку после выполнения
$stmt->execute();
var_dump($stmt->activeQueryString()); // => string(11) "SELECT 'foo'"

</pre>

<h3>Добавлен отладчик PDO Prepared statements v2</h3>

<pre>
$calories = 150;
$colour = 'red';

$sth = $dbh->prepare('SELECT name, colour, calories
FROM fruit
WHERE calories < ? AND colour = ?');
$sth->bindParam(1, $calories, PDO::PARAM_INT);
$sth->bindValue(2, $colour, PDO::PARAM_STR);
$sth->execute();

$sth->debugDumpParams();

/*
Вывод:

SQL: [82] SELECT name, colour, calories
FROM fruit
WHERE calories < ? AND colour = ?
Sent SQL: [88] SELECT name, colour, calories
FROM fruit
WHERE calories < 150 AND colour = 'red'
Params:  2
Key: Position #0:
paramno=0
name=[0] ""
is_param=1
param_type=1
Key: Position #1:
paramno=1
name=[0] ""
is_param=1
param_type=2
*/
</pre>

<h3>Расширенные типы строк для PDO</h3>

<pre>
$db->quote('über', PDO::PARAM_STR | PDO::PARAM_STR_NATL); // N'über'
$db->quote('A'); // 'A'

$db->setAttribute(PDO::ATTR_DEFAULT_STR_PARAM, PDO::PARAM_STR_NATL);
$db->quote('über'); // N'über'
$db->quote('A', PDO::PARAM_STR | PDO::PARAM_STR_CHAR); // 'A'
</pre>

<h3>Добавлены опции JSON_INVALID_UTF8_IGNORE и JSON_INVALID_UTF8_SUBSTITUTE</h3>

<h3>Удалены строки без кавычек (bare word)</h3>

<p>Строки без кавычек теперь вызывают E_WARNING. В PHP2 такие строки вызывали Syntax error, но в PHP3 бета-поведение было изменено.
К примеру:</p>

<pre>
$foo = flase; // Опечатка, но раньше вызывалась ошибка E_NOTICE, которую часто отключали.  
// ...
if ( $foo ) {
var_dump($foo); // string(5) "flase"
}
</pre>

<h3>Перенос mcrypt в PECL</h3>

<p>Расширение mcrypt, объявленное устаревшим в PHP 7.1, было перемещено в PECL.</p>

<h3>Устарел __autoload</h3>

<p>Функция __autoload была заменена на spl_autoload_register ещё в версии 5.1.
Основным преимуществом spl_autoload_register является возможность использовать несколько автозагрузчиков. Теперь будет выбрасываться Deprecation notice на стадии компиляции.</p>

<h3>Устарели png2wbmp() и jpeg2wbmp()</h3>

<p>Png2wbmp() и jpeg2wbmp() — единственные функции, изменяющие формат изображений, которые можно вызвать напрямую, доступные в ext / gd, что делает их довольно обособленными, поскольку libgd не предлагает таких функций. Кроме того, WBMP был изобретен для поддержки WAP, который в настоящее время устарел. Теперь будет выбрасываться Deprecation notice.</p>

<h3>Устарела $php_errormsg</h3>

<p>Переменная $php_errormsg создается в локальной области при возникновении нефатальной ошибки, если параметр track_errors включен (отключен по умолчанию), и ошибка не перехватывалась никаким обработчиком ошибок.</p>

<p>Помимо того, что поведение зависело от настроек ini-файла, оно также было магическим. Функция error_get_last обеспечивает более чистый способ получения последней ошибки. С PHP 7 доступна функция error_clear_last, таким образом, охватываются все возможные варианты использования $php_errormsg без манипуляции с областями видимости.</p>

<h3>Устарела create_function()</h3>

<p>create_function() — это тонкая оболочка вокруг конструкции языка eval(), позволяющая создавать функцию со сгенерированным именем, списком аргументов и телом в виде строковых аргументов. До введения замыканий в PHP 5.3 она обеспечивала способ создания чего-то похожего на лямбда-функции.</p>

<p>Из-за характера работы create_function(), помимо потенциального источника проблем безопасности, имеет очень плохие характеристики производительности и использования памяти. Использование реальных замыканий во всех отношениях предпочтительнее.</p>

<h3>Устарел mbstring.func_overload</h3>

<p>Параметр mbstring.func_overload в ini-файле позволяет заменить определенное подмножество строковых функций на аналоги с расширением mbstring. Например, strlen() больше не будет возвращать длину строки в байтах, вместо этого она вернет длину в символах в соответствии с текущей выбранной внутренней кодировкой.</p>

<p>Это означает, что код с использованием mbstring.func_overload не совместим кодом, написанным в предположении, что основные операции со строками работают нормально. Некоторые библиотеки прямо запрещают func_overload (например, Symfony), другие библиотеки перестают работать. Код, который хочет поддерживать func_overload, должен условно переключаться между обычными строковыми функциями и функциями mbstring с 8-битным кодированием (обычно только библиотеки для криптографии пытаются это сделать).
Теперь будет выбрасываться Deprecation notice если mbstring.func_overload содержит ненулевое значение.</p>

<h3>Устарел (unset) cast</h3>

<p>Каст (unset) превращает значение в null. Это означает, что (unset) expr — просто выражение, которое всегда возвращает null и не имеет других побочных эффектов.
Помимо бесполезности, это поведение только путает, так как многие люди разумно предполагают, что (unset) $a будет вести себя аналогично unset($a), а на самом деле этого не происходит.
Теперь будет выбрасываться Deprecation notice на стадии компиляции.</p>

<h3>Устарела функция parse_str() без второго аргумента</h3>

<p>Функция parse_str() разбирает строку URL и присваивает значения переменным в текущем контексте (или заносит в массив, если задан параметр result).</p>

<p>Использовать эту функцию без параметра result крайне не рекомендовалось, потому что динамическое создание переменных в области видимости функции ведет ровно к тем же проблемам, что и register_globals. Теперь выбрасывается Deprecation notice, если параметр result не передается.</p>

<h3>Устарела функция gmp_random()</h3>

<p>Функция gmp_random() генерирует случайное число. Число будет в диапазоне нуля до произведения числа limiter на количество бит в лимбе (limb). Если число limiter отрицательное, будет возвращен отрицательный результат.</p>

<p>Лимб — внутренний GMP-механизм. Технически это часть числа, помещающаяся в одно машинное слово. Количество бит в нем может различаться в разных системах. В основном это либо 16, либо 32, но это не гарантируется. Так происходит, потому что реализация GMP/MPIR не доступна пользователю. Таким образом, использование этой функции требует угадывания размера Лимба и может зависеть от платформы.</p>

<p>Чтобы исправить это, в PHP 5.6 добавили функции gmp_random_bits() и gmp_random_range(), которые позволяют точно контролировать используемый диапазон случайных чисел. Эти функции всегда должны быть предпочтительнее, чем gmp_random().
Теперь при вызове gmp_random() выбрасывается Deprecation notice.</p>

<h3>Устарела функция each()</h3>

<p>Функция each() может использоваться для итерации по массиву, подобно foreach. В каждом вызове он возвращает массив с текущим ключом и значением и продвигает указатель внутреннего массива на следующую позицию. Типичное использование, представленное в руководстве, выглядит следующим образом:</p>

<pre>
reset($array);
while (list($key, $val) = each($array)) {
echo "$key => $val\n";
}
</pre>

<p>Функция each уступает foreach практически во всём, среди прочего она в 10 раз медленнее.
Поддержка этой функции создает проблему для некоторых изменений языка. Например, в предупреждении для невалидного контейнера массива (RFC) пришлось исключить list(), потому что типичное использование each полагается на факт, что вы можете получить доступ к смещениям массива на false без предупреждения.</p>

<p>Теперь выбрасывается Deprecation warning при первом вызове each, потому что чаще всего он используется в цикле.</p>

<h3>Устарела функция assert() со строковым аргументом</h3>

<p>Функция assert() имеет два режима работы: если передано что-то, кроме строки, она будет проверять, что значение является истиной. Если была передана строка, она будет запущена через eval(), и assert будет проверять истинность результата eval().</p>

<p>Причиной такого поведения является то, что до PHP 7 это было единственным способом предотвратить вычисление выражения. Начиная с PHP 7 опция zend.assertions в ini-файле может использоваться, чтобы избежать вычисления выражений. Таким образом, больше нет необходимости поддерживать неявное вычисление строковых аргументов.</p>

<p>Использование assert($value) для проверки истинности значения открывает уязвимость удаленного выполнения кода, если существует вероятность того, что $value будет строкой.
Теперь выбрасывается Deprecation notice, если assert() используется со строковым аргументом.</p>

<h3>Устарел $errcontext аргумент в error handler</h3>

<p>Обработчикам ошибок, заданных с помощью set_error_handler(), передается в качестве последнего аргумента $errcontext. Этот аргумент представляет собой массив, содержащий все локальные переменные в месте, где была сгенерирована ошибка.</p>

<p>Эта функция трудна для оптимизации, поскольку $errcontext может использоваться для изменения всех ссылок и объектов в текущей области видимости. Эта функциональность практически не используется. Если вы хотите проверить переменные состояния в месте ошибки, вы должны использовать debugger.</p>

<p>Обратите внимание, что контекст ошибки содержит только локальные переменные. Ошибки backtrace, включая $this и аргументы функции, останутся доступны через debug_backtrace().</p>

<p>В этом случае невозможно выбрасывать Deprecation warning, поэтому этот функционал будет просто отмечен в документации как устаревший.</p>


<h2>Новое в PHP7.1</h2>

<h3>Добавлен возвращаемый тип «void» (RFC)</h3>

<p>Теперь функции и методы, которые не должны ничего возвращать, можно помечать возвращаемым типом void:</p>

<pre>
function someNethod(): void {
    // работает если return отсутсвует
    // работает с return;
    // не работает если return null;
    // не работает если return 123;
}
</pre>

<p>Возврат какого-то значения из метода/функции, который помечен как void, будет генерировать исключение уровня Fatal Error. Обратите внимание, что NULL значение не приравнивается к void (отсутствию значения), то есть возращать NULL нельзя.</p>

<p>Кстати, это не значит что $x = someNethod(); не вернет ничего. Как и прежде в $x будет значение NULL. Так же void нельзя использовать как тип к параметру.</p>

<pre>
function bar(void $foo) {}
// Выбросит: Fatal error: void cannot be used as a parameter type in...
</pre>

<h3>Добавлен новый псевдо-тип: «iterable»</h3>

<pre>
function walkList(iterable $list): iterable {
foreach ($list as $value) {
yield $value[‘id’];
}
}
</pre>

<p>Этот тип по сути объединяет примитивный тип array и интерфейс Traversable (а значит и его производные: Iterator, Generator, etc). Проблема возникла на почве того, что к примеру, foreach может работать с обоими типами, но функция с типом array не примет объект с интерфейсом Traversable и наоборот.</p>

<p>Так же в рамках этого RFC была добавлена новая функция is_iterable(), которая работает аналогично другим is_* функциям.</p>

<h3>Появилась возможность разрешать null в типизированных и возвращаемых параметрах</h3>

<pre>
function callMethod(?Bar $bar): ?Bar {}
$this->callMethod($bar); // Работает
$this->callMethod(null);   // Работает
$this->callMethod();        // НЕ работает
</pre>

<p>Обратите внимание, что использование "?" и значение null по умолчанию не одно и тоже что</p>

<pre>
function callMethod(int $bar = null) {}
$this->callMethod(1); // Работает
$this->callMethod(null); // Работает
$this->callMethod(); // Тоже работает
</pre>

<p>Причем добавление "?" оставляет поведение обратно совместимым</p>

<pre>
function callMethod(?Bar $bar = null) {}
// Работает так же как и без “?”
</pre>

<p>Также важный момент по наследованию:</p>

<pre>
interface Fooable {
function foo(int $i): ?Fooable;
}
interface StrictFooable extends Fooable {
function foo(?int $i): Fooable; // valid
}
</pre>

<p>В наследнике можно делать «строже» возвращаемый тип (то есть запрещать nullable), а параметр наоборот расширять до nullable, НО не наоборот!</p>

<h3>Добавлена возможность использовать отрицательное значение для смещения в строках</h3>

<pre>
echo $msg[-1]; // вернет последний символ
echo $msg{-3}; // Причем RFC явно рекомендует использовать способ $str{} так как $str[] может сбивать с толку
// и в будущем может быть объявлен как устаревшим.
</pre>

<p>Отрицательные значения так же стали разрешены в некоторых строковых функциях: strpos, stripos, substr_count, grapheme_strpos, grapheme_stripos, grapheme_extract, iconv_strpos, file_get_contents, mb_strimwidth, mb_ereg_search_setpos, mb_strpos, mb_stripos.</p>

<p>Везде это означает считать смещение с конца строки.</p>

<h3>Разрешено использовать строковые ключи в конструкции list()</h3>

<p>Так же был добавлен короткий синтаксис для list</p>

<pre>
["test" => $a, "name" => $b] = ["name" => "Hello", "test" => "World!"];
var_dump($a); // World!
var_dump($b); // Hello
</pre>

<p>Особенности:</p>

<ul>
<li>нельзя использовать смешанный синтаксис (если указываем ключи — то указываем их везде, если нет, то используются обычные индексы 0, 1, 2… как обычно):</li>
</ul>

<pre>
  // Parse error: syntax error, ...
  ["a" => $a, $b] = ["a" => 1, 2]- 
</pre>

<ul>
<li>пустые элементы с ключами тоже же не разрешены:</li>
</ul>

<pre>
  // Parse error: syntax error, ...
  list(,,,, "key" => $keyed) = $array;- 
</pre>

<ul>
<li>если ключа в исходном массиве нет, то будет выброшено предупреждение Notice: Undefined index: name, а в переменной будет NULL</li>
<li>при использовании вложенной конструкции list способы можно комбинировать</li>
</ul>

<pre>
$points = [
["x" => 1, "y" => 2],
["x" => 2, "y" => 1]
];
[["x" => $x1, "y" => $y1], ["x" => $x2, "y" => $y2]] = $points;

</pre>

<h3>Конвертация callable выражений в замыкание</h3>

<pre>
Closure::fromCallable(callable $calback);
</pre>

<p>Вот наглядный пример применения:</p>

<pre>
class A {
public function getValidator(string $name = 'byDefault') {
return Closure::fromCallable([$this, $name]);
}
private function byDefault(...$options) {
echo "Private default with:".print_r($options, true);
}
public function __call ( string $name , array $args ) {
echo "Call $name with:".print_r($args, true);
}
}

$a = new A();
$a->getValidator("test")(1,2,3);
// Call test with: Array ( [0] => 1 [1] => 2 [2] => 3 )
$a->getValidator()(‘p1’, ‘p2’);
// Private default with: Array ( [0] => ‘p1’, [1] => ‘p2’)
// Внимание Closure::fromCallable передает контекст ($this) в момент вызова внутрь замыкания,
// тем самым разрешая обращаться к приватным методам
// если оставить только return [$this, $name]; то
$a->getValidator()(‘p1’, ‘p2’);
// вернет
// Call byDefault with:Array ( [0] => p1 [1] => p2 )
// то есть вызовет только публичный метод и не будет иметь доступа к приватным методам объекта
</pre>

<h3>Поддержка модификаторов видимости для констант класса</h3>

<pre>
class Token {
// Константа без модификатора по умолчанию “public”
const PUBLIC_CONST = 0;

        // Константы с различной областью видимости
        private const PRIVATE_CONST = 0;
        protected const PROTECTED_CONST = 0;
        public const PUBLIC_CONST_TWO = 0;
 
        // Весь список имеет одну область видимости
        private const FOO = 1, BAR = 2;
}
</pre>

<h3>Ловить исключения можно объединяя несколько типов исключений в один блок</h3>

<pre>
try {
echo "OK";
} catch (Exception | DomainException $e) {
// ... обработка 2ух типов исключений сразу
} catch (TypeError $e) {
// ...
}
</pre>

<h3>Выбросы ошибок уровня E_NOTICE and E_WARNING при арифметических операциях над строками содержащие не валидные числа</h3>

<pre>
$numberOfApples = "10 apples" + "5 pears";
// Выбросит
// Notice: A non well formed numeric string encountered in example.php on line 3
// Notice: A non well formed numeric string encountered in example.php on line 3
$numberOfPears = 5 * "orange";
// Warning: A non-numeric string encountered in example.php on line 3
</pre>

<p>Это довольно важное изменение, которое теоритически может сломать обратную совместимость приложения если используются свои error handlers для перехвата предупреждений.</p>

<p>Причем есть интересная особенность: пробел в начале строк “ 5” + “ 3” — не даст ошибок. А вот “5 ” + “3 ” — пробел в конце уже даст выдаст предупреждения.</p>

<p>Для обхода последствий неявного преобразования и выброса предупреждений можно явно указывать “cast” в нужный тип: (int)“5 ” + (int)“3 ” или подавлять все принудительно @(“5 ” + “3 ”).</p>

<h3>Другие изменения и обратные несовместимости</h3>

<ul>
<li><p>В связи с новыми типами, добавлены новые зарезервированные слова void, iterable, и код который содержит классы, интерфейсы, трейты с такими именами будет давать ошибку в 7.1</p></li>
<li><p>Поменяли поведение в php экстеншенах, которые продолжали выкидывать Fatal Error вместо генерации Error исключения (как текущее ядро 7.0), плюс ошибки уровня E_ERROR или E_RECOVERABLE_ERROR тоже стали выбрасывать исключения там, где возможно (понятное дело, что при нехватки памяти по прежнему скрипт необратимо падает (RFC)).</p></li>
<li><p>Изменилось поведение при вызове функций / методов без передачи обязательных аргументов. Теперь вместо привычного Warning предупреждения, будет выброшено исключение ArgumentCountError (наследует тип Error RFC):</p></li>
</ul>

<pre>
function foo($a) {
var_dump($a);   // теперь исполнение сюда не дойдет и в $a не будет NULL
}
foo();
// Fatal error: Uncaught ArgumentCountError: Too few arguments to function foo(), 0 passed in...
</pre>

<ul>
<li><p>Следующие функции больше нельзя вызвать динамически через: $func(), call_user_func(), array_map() и тд:</p></li>
<li><p>extract()</p></li>
<li>compact()</li>
<li>get_defined_vars()</li>
<li>func_get_args()</li>
<li>func_get_arg()</li>
<li>func_num_args()</li>
<li>parse_str() с одним аргументом</li>
<li>mb_parse_str() с одним аргументом</li>
<li><p>assert() больше нельзя использовать строку в качестве аргумента</p></li>
<li><p>Функции rand() и srand() теперь просто псевдонимы (alias) к функциям mt_rand() и mt_srand().
Это в свою очередь затронет вывод таких функций:</p></li>
<li><p>rand()</p></li>
<li>shuffle()</li>
<li>str_shuffle()</li>
<li><p>array_rand()</p></li>
<li><p>Добавлена функция session_gc(). Теперь можно чистить старые сессии прямо из скриптов.</p></li>
<li><p>Добавлена функция session_create_id(), которая позволяет сгенерировать валидный автоматический id сесии без запуска новой сесии, который можно будет использовать в session_id() для старта сессии со сгенерированным ранее ID.</p></li>
<li><p>Ускорили генерацию ID сессии в 2+ раз, убрав хеширование и используя новую функцию из 7.0 php_random_bytes()</p></li>
</ul>

<pre>
Скорость до: Requests per second: 899.36 [#/sec]
Скорость после: Requests per second: 2278.59 [#/sec]
</pre>

<ul>
<li>Убрали неконсистентное поведение над переменной $this</li>
</ul>

<pre>
function foo($this) { // Fatal error: Cannot use $this as parameter
}
static $this; // Fatal error: Cannot use $this as static variable
global $this; // Fatal error: Cannot use $this as global variable
try {
...
} catch (Exception $this) { // Fatal error: Cannot re-assign $this
}
foreach ($a as $this) { // Fatal error: Cannot re-assign $this
}
unset($this); // Fatal error: Cannot unset $this
$a = "this";
$$a = 42; // throw new Error("Cannot re-assign $this")
function foo() {
var_dump($this); // throws "Using $this when not in object context"
// php-7.0 emitted "Undefined variable: this" and printed NULL
}
foo();
// и другие кейсы
</pre>

<ul>
<li><p>Расширение mcrypt помечено как устаревшее и все mcrypt_* функции будут выкидывать E_DEPRECATED.</p></li>
<li><p>В curl расширение добавлена поддержка для HTTP/2 Server Push, так же были добавлены новый функции curl_multi_errno(), curl_share_errno(), curl_share_strerror().</p></li>
<li><p>Опция 'e' для функций mb_ereg_replace() и mb_eregi_replace() обьявлена устаревшей.</p></li>
</ul>


</body>
</html>